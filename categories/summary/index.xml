<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Summary on True Me </title>
    <link>https://zetaoyang.github.io/categories/summary/</link>
    <description>Recent content in Summary on True Me </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Zetao的小站</copyright>
    <lastBuildDate>Sun, 09 Oct 2016 10:43:34 +0800</lastBuildDate>
    <atom:link href="https://zetaoyang.github.io/categories/summary/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>生成渐进式 jpeg</title>
      <link>https://zetaoyang.github.io/post/post-02/</link>
      <pubDate>Sun, 09 Oct 2016 10:43:34 +0800</pubDate>
      
      <guid>https://zetaoyang.github.io/post/post-02/</guid>
      <description>&lt;p&gt;用&lt;code&gt;python&lt;/code&gt;实现了一个带参数的命令行将图片转换成&lt;code&gt;progressive encoding&lt;/code&gt;(渐进式)JPEG格式。&lt;br /&gt;
　　这里先贴出代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#! python3
import platform, sys, os
import getopt
from PIL import Image ,ImageFile

def isWindows():
    return &#39;Windows&#39; in platform.system()
 
def isLinux():
    return &#39;Linux&#39; in platform.system()

def usage():
    print (&amp;quot;-h: This message.&amp;quot;)
    print (&amp;quot;-i [file]: the path of the target image file. &amp;quot;)
    print (&amp;quot;-o [filepath]: the path of the output. &amp;quot;)
    print (&amp;quot;EXAMPLES:&amp;quot;)
    print (&amp;quot;$py tojpeg.py -i /home/test.jpg - o /home&amp;quot;)

def info():
    print (&amp;quot;**************************************************&amp;quot;)
    print (&amp;quot;**|&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;|**&amp;quot;)
    print (&amp;quot;**|convert images to progressive encoding JPEG |**&amp;quot;)
    print (&amp;quot;**|Version: 1 beta                             |**&amp;quot;)
    print (&amp;quot;**|By: zetao yang                              |**&amp;quot;)
    print (&amp;quot;**|Email: yangzetao2015[@] outlook             |**&amp;quot;)
    print (&amp;quot;**|https://zetaoyang.github.io                 |**&amp;quot;)
    print (&amp;quot;**|-                                           |**&amp;quot;)
    print (&amp;quot;**|Usage: $tojpeg -h                           |**&amp;quot;)
    print (&amp;quot;**|                                            |**&amp;quot;)
    print (&amp;quot;**|,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,|**&amp;quot;)
    print (&amp;quot;**************************************************&amp;quot;)
    print (&amp;quot;&amp;quot;)

if(isWindows()):
   os.system(&amp;quot;cls&amp;quot;)
if(isLinux()):
   os.system(&amp;quot;clear&amp;quot;)

def main():
    info()
    try:
        #使用sys.argv[1:] 过滤掉第一个参数
        #（它是执行脚本的名字，不应算作参数的一部分）
        opts,args = getopt.getopt(sys.argv[1:],&amp;quot;hi:o:&amp;quot;, [&amp;quot;help&amp;quot;,&amp;quot;input=&amp;quot; ,&amp;quot;output=&amp;quot;])
    except getopt.GetoptError as err:
        print (err)
        sys.exit(2)

    for opt, arg in opts:
        if opt in (&amp;quot;-h&amp;quot;,&amp;quot;--help&amp;quot;):
            usage()
            sys.exit()
        elif opt in (&amp;quot;-i&amp;quot;,&amp;quot;--input&amp;quot;):
            input_file = arg
        elif opt in (&amp;quot;-o&amp;quot;,&amp;quot;--output&amp;quot;):
            output_path = arg
        else:
            assert False, &amp;quot;unhandled option&amp;quot;

    try:
        img = Image.open(input_file)
        destination = output_path + &amp;quot;/output.jpeg&amp;quot;
        try:
            img.save(destination,&amp;quot;JPEG&amp;quot;,quality=80,optimize=True,progressive=True)
            print(&amp;quot;conversion is ok.&amp;quot;)
        except IOError:
            ImageFile.MAXBLOCK = img.size[0]*img.size[1]
            img.save(destination,&amp;quot;JPEG&amp;quot;,quality=80,optimize=True,progressive=True)
    except KeyboardInterrupt:
        print (&amp;quot;\nWell i hope you had a good time.&amp;quot;)
        
if __name__ == &amp;quot;__main__&amp;quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;未完待续&amp;hellip;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用Github API 上传文件的方法</title>
      <link>https://zetaoyang.github.io/post/post-01/</link>
      <pubDate>Sat, 08 Oct 2016 11:04:19 +0800</pubDate>
      
      <guid>https://zetaoyang.github.io/post/post-01/</guid>
      <description>&lt;p&gt;前几天，在V2EX看见有人用Github API基于python实现了一个图床。于是我决定用nodejs也实现一个类似功能。首先我看有没现成的第三方库，在 &lt;a href=&#34;https://developer.github.com/libraries/&#34;&gt;Libraries | GitHub Developer Guide&lt;/a&gt; 我发现有5个跟javascript相关的库：&lt;br /&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://cdn.rawgit.com/qanno/qanno.github.io/master/images/github-api-js.png&#34; alt=&#34;github-api-js.jpg&#34; /&gt;&lt;br /&gt;
&lt;/div&gt;
经调研发现 &lt;a href=&#34;https://github.com/michael/github&#34;&gt;GitHub.js wrapper around the GitHub API&lt;/a&gt; 比较好入手，基本将Github API 全都实现了，并且封装了自己的接口，但是缺点还是有的，文档写的不太详细。然后就开始看它的文档，其中Repository的writeFile()方法就是上传文件的函数。&lt;br /&gt;
其中writeFile():&lt;br /&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://cdn.rawgit.com/qanno/qanno.github.io/master/images/github-api-writeFile-2.3.0.png&#34; alt=&#34;github-api-writeFile-2.3.0.png&#34; /&gt;&lt;br /&gt;
&lt;/div&gt;&lt;br /&gt;
　　 先在这里贴出代码(ECMAScript 2015标准)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//导入github-api
var GitHub = require(&amp;quot;github-api&amp;quot;)
var fs = require(&amp;quot;fs&amp;quot;)

const gh = new GitHub({
	token: &#39;&amp;lt;your personal token&amp;gt;&#39;//这里采用token认证
})

var branch = &#39;&amp;lt;branch_name&amp;gt;&#39;//eg. master
var ufilePath = &#39;&amp;lt;repo_path&amp;gt;&#39;//eg. images/
//{master}/xxx.jpg
var ufileName = &#39;&amp;lt;file_name&amp;gt;&#39;//eg. xxx.jpg
var commit = &#39;here i am&#39;
var user = &#39;&amp;lt;user name&amp;gt;&#39;//用户名
var repo = &#39;&amp;lt;repository name&amp;gt;&#39;//仓库名

const re = gh.getRepo(user,repo)

//同步读取文件
var imageBlob = fs.readFileSync(&#39;&amp;lt;filepath&amp;gt;&#39;)
//base64编码
var imageB64 = imageBlob.toString(&#39;base64&#39;)
//ascii编码
//utf8编码也可以，只不过有些浪费。
var data = imageB64.toString(&#39;ascii&#39;)

var options = {
    //author:{},
    //commiter:{},
    encode: false
}

re.writeFile(branch, ufilePath + ufileName, data , commit,options, (error,result,request)=&amp;gt;{
    if (error===null) {	console.log(`https://cdn.rawgit.com/${user}/${repo}/${branch}/${ufilePath}${ufileName}`)
	 }
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　 这其中的关键就是编码问题， GitHub Contents API 要求content是base64编码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>非对称加密(RSA)数据传送的实战</title>
      <link>https://zetaoyang.github.io/post/post-03/</link>
      <pubDate>Thu, 06 Oct 2016 21:24:17 +0800</pubDate>
      
      <guid>https://zetaoyang.github.io/post/post-03/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;建议先了解一下RSA原理，再看本文。推荐阮一峰老师的两篇文章：&lt;br /&gt;
* &lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&#34;&gt;RSA算法原理（一）&lt;/a&gt;&lt;br /&gt;
* &lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html&#34;&gt;RSA算法原理（二）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为&lt;code&gt;php&lt;/code&gt;支持的密钥格式是&lt;code&gt;.pem&lt;/code&gt;所以&lt;code&gt;web&lt;/code&gt;和&lt;code&gt;java&lt;/code&gt;端都要将&lt;code&gt;pem&lt;/code&gt;格式转换成其语言平台支持的格式。 比如，&lt;code&gt;java&lt;/code&gt;支持的格式默认是&lt;code&gt;.asn&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;密钥对的生成-php&#34;&gt;密钥对的生成(php)&lt;/h3&gt;

&lt;p&gt;如果系统是&lt;code&gt;Linux&lt;/code&gt;的话，可以使用&lt;code&gt;openssl&lt;/code&gt;命令来生成。这里展示的是在&lt;code&gt;Windows&lt;/code&gt;系统下的操作(因为当时做这个东西的时候是在Windows 8.1系统下完成的)，使用 &lt;a href=&#34;https://www.apachefriends.org/zh_cn/index.html&#34;&gt;xampp&lt;/a&gt; 集成好的&lt;code&gt;openssl&lt;/code&gt;(其配置文件路径在xampp的安装路径下的php\extras\openssl\openssl.cnf，我们这次使用的就是这个文件)，下面展示用&lt;code&gt;php&lt;/code&gt;来生成密钥对：(n和e组成公钥，n和d组成私钥)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
//OPENSSL_CNF为 openssl.cnf 的路径
define(&#39;OPENSSL_CNF&#39;,&#39;&amp;lt;your openssl.cnf path &amp;gt;&#39;);
define(&#39;SHA&#39;,&amp;quot;sha512&amp;quot;);
define(&#39;LENGTH&#39;,2048);

header(&amp;quot;Content-type:text/html;charset=utf-8&amp;quot;);
$configargs=array(
	&#39;config&#39;=&amp;gt; OPENSSL_CNF,
	&amp;quot;digest_alg&amp;quot; =&amp;gt; SHA,
    &amp;quot;private_key_bits&amp;quot; =&amp;gt; LENGTH,
    &amp;quot;private_key_type&amp;quot; =&amp;gt; OPENSSL_KEYTYPE_RSA,);
$res=openssl_pkey_new($configargs);
openssl_pkey_export($res,$pri,null, $configargs);

/*Binary Data to Decimal Data
 * @param string $data
 * @return string $result
 * */
function hexTobin($hexString) 
    { 
        $hexLenght = strlen($hexString); 
        // only hexadecimal numbers is allowed 
        if ($hexLenght % 2 != 0 || preg_match(&amp;quot;/[^\da-fA-F]/&amp;quot;,$hexString)) return FALSE; 

        unset($binString); 
        for ($x = 1; $x &amp;lt;= $hexLenght/2; $x++) 
        { 
                $binString .= chr(hexdec(substr($hexString,2 * $x - 2,2))); 
        } 

        return $binString; 
    } 
 
/* Binary Data to Decimal Data
 * @param string $data
 * @return string $result
 **/
function binTodec($data)
	{
		$base = &amp;quot;256&amp;quot;;
		$radix = &amp;quot;1&amp;quot;;
		$result = &amp;quot;0&amp;quot;;

		for($i = strlen($data) - 1; $i &amp;gt;= 0; $i--)
		{
			$digit = ord($data{$i});
			$part_res = bcmul($digit, $radix);
			$result = bcadd($result, $part_res);
			$radix = bcmul($radix, $base);
		}

		return $result;
	}

$details=openssl_pkey_get_details($res);

$n_hex=bin2hex($details[&#39;rsa&#39;][&#39;n&#39;]);
$d_hex=bin2hex($details[&#39;rsa&#39;][&#39;d&#39;]);
$e_hex=bin2hex($details[&#39;rsa&#39;][&#39;e&#39;]);

$n_dec=binTodec($details[&#39;rsa&#39;][&#39;n&#39;]);
$d_dec=binTodec($details[&#39;rsa&#39;][&#39;d&#39;]);
$e_dec=binTodec($details[&#39;rsa&#39;][&#39;e&#39;]);

openssl_pkey_free($res);

$pub=$details[&#39;key&#39;];

$crtpath = &amp;quot;./test.crt&amp;quot;; //公钥文件路径  
$pempath = &amp;quot;./test.pem&amp;quot;; //私钥文件路径  

$n_hexpath = &amp;quot;./n_hex.key&amp;quot;; //n_hex文件路径  
$d_hexpath = &amp;quot;./d_hex.key&amp;quot;; //d_hex文件路径  
$e_hexpath = &amp;quot;./e_hex.key&amp;quot;; //e_hex文件路径 

$n_decpath = &amp;quot;./n_dec.key&amp;quot;; //n_dec文件路径  
$d_decpath = &amp;quot;./d_dec.key&amp;quot;; //d_dec文件路径  
$e_decpath = &amp;quot;./e_dec.key&amp;quot;; //e_dec文件路径 

//生成证书文件  
$fp = fopen($crtpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $pub);  
fclose($fp);  

$fp = fopen($pempath, &amp;quot;w&amp;quot;);  
fwrite($fp, $pri);  
fclose($fp);  
//生成n_hex,d_hex,e_hex文件
$fp = fopen($n_hexpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $n_hex);  
fclose($fp);  

$fp = fopen($d_hexpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $d_hex);  
fclose($fp);  

$fp = fopen($e_hexpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $e_hex);  
fclose($fp); 
//生成n_dec,d_dec,e_dec文件
$fp = fopen($n_decpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $n_dec);  
fclose($fp);  

$fp = fopen($d_decpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $d_dec);  
fclose($fp);  

$fp = fopen($e_decpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $e_dec);  
fclose($fp); 

var_dump($pub);
echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;
var_dump($pri);
$pu_key = openssl_pkey_get_public($pub);
print_r($pu_key);
echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;
$data = &#39;plaintext data goes here.&#39;;

// Encrypt the data to $encrypted using the public key
openssl_public_encrypt($data, $encrypted,$pub,OPENSSL_PKCS1_PADDING);

// Decrypt the data using the private key and store the results in $decrypted
openssl_private_decrypt($encrypted, $decrypted, $pri,OPENSSL_PKCS1_PADDING);

echo $encrypted.&amp;quot; &amp;quot;.strlen($encrypted).&amp;quot;   &amp;quot;.base64_encode($encrypted).&amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;
echo $decrypted;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;java&#34;&gt;java&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;此处的核心代码是我从互联网上搜索到的，出处已经记不清是哪了，还请原作者见谅。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private String _key;
private KeyFormat _format;
private Cipher _decryptProvider;
private Cipher _encryptProvider;

public KeyWorker(String key) {
	this(key, KeyFormat.ASN);
}

public KeyWorker(String key, KeyFormat format) {
	this._key = key;
	this._format = format;
}

public String encrypt(String data) throws IllegalBlockSizeException,
BadPaddingException, InvalidKeyException, NoSuchAlgorithmException,
NoSuchPaddingException, InvalidKeySpecException, IOException, SAXException, ParserConfigurationException {
	this._makesureEncryptProvider();
	byte[] bytes = data.getBytes(&amp;quot;UTF-8&amp;quot;);
	bytes = this._encryptProvider.doFinal(bytes);
	return new BASE64Encoder().encode(bytes);
}

public String decrypt(String data) throws IOException,
IllegalBlockSizeException, BadPaddingException,
InvalidKeyException, NoSuchAlgorithmException,
NoSuchPaddingException, InvalidKeySpecException, SAXException, ParserConfigurationException {
	this._makesureDecryptProvider();
	
	byte[] bytes = new BASE64Decoder().decodeBuffer(data);
	bytes = this._decryptProvider.doFinal(bytes);
	return new String(bytes, &amp;quot;UTF-8&amp;quot;);
}

private void _makesureDecryptProvider() throws NoSuchAlgorithmException,
NoSuchPaddingException, IOException, InvalidKeySpecException,
InvalidKeyException, SAXException, ParserConfigurationException {
if (this._decryptProvider != null)
	return;

Cipher deCipher = Cipher.getInstance(&amp;quot;RSA/ECB/PKCS1Padding&amp;quot;);
switch (this._format) {

case PEM: {
	this._key = this._key.replace(&amp;quot;-----BEGIN PUBLIC KEY-----&amp;quot;, &amp;quot;&amp;quot;)
			.replace(&amp;quot;-----END PUBLIC KEY-----&amp;quot;, &amp;quot;&amp;quot;)
			.replace(&amp;quot;-----BEGIN PRIVATE KEY-----&amp;quot;, &amp;quot;&amp;quot;)
			.replace(&amp;quot;-----END PRIVATE KEY-----&amp;quot;, &amp;quot;&amp;quot;)
			.replaceAll(&amp;quot;\r\n&amp;quot;, &amp;quot;&amp;quot;);
}
case ASN:
default: {
	Boolean isPrivate = this._key.length() &amp;gt; 500;
	if (isPrivate) {
		PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(
				new BASE64Decoder().decodeBuffer(this._key));

		KeyFactory factory = KeyFactory.getInstance(&amp;quot;RSA&amp;quot;);
		RSAPrivateKey privateKey = (RSAPrivateKey) factory
				.generatePrivate(spec);
		deCipher.init(Cipher.DECRYPT_MODE, privateKey);
	} else {
		X509EncodedKeySpec spec = new X509EncodedKeySpec(
				new BASE64Decoder().decodeBuffer(this._key));

		KeyFactory factory = KeyFactory.getInstance(&amp;quot;RSA&amp;quot;);
		RSAPublicKey publicKey = (RSAPublicKey) factory
				.generatePublic(spec);
		deCipher.init(Cipher.DECRYPT_MODE, publicKey);
	}
}
	break;
}

this._decryptProvider = deCipher;
}

private void _makesureEncryptProvider() throws NoSuchAlgorithmException,
NoSuchPaddingException, IOException, InvalidKeySpecException,
InvalidKeyException, SAXException, ParserConfigurationException {
if (this._encryptProvider != null)
	return;

Cipher enCipher = Cipher.getInstance(&amp;quot;RSA/ECB/PKCS1Padding&amp;quot;);
switch (this._format) {

case PEM: {
	this._key = this._key.replace(&amp;quot;-----BEGIN PUBLIC KEY-----&amp;quot;, &amp;quot;&amp;quot;)
			.replace(&amp;quot;-----END PUBLIC KEY-----&amp;quot;, &amp;quot;&amp;quot;)
			.replace(&amp;quot;-----BEGIN PRIVATE KEY-----&amp;quot;, &amp;quot;&amp;quot;)
			.replace(&amp;quot;-----END PRIVATE KEY-----&amp;quot;, &amp;quot;&amp;quot;)
			.replaceAll(&amp;quot;\r\n&amp;quot;, &amp;quot;&amp;quot;);
}
case ASN:
default: {
	Boolean isPrivate = this._key.length() &amp;gt; 500;
	if (isPrivate) {
		PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(
				new BASE64Decoder().decodeBuffer(this._key));

		KeyFactory factory = KeyFactory.getInstance(&amp;quot;RSA&amp;quot;);
		RSAPrivateKey privateKey = (RSAPrivateKey) factory
				.generatePrivate(spec);
		enCipher.init(Cipher.ENCRYPT_MODE, privateKey);

	} else {
		X509EncodedKeySpec spec = new X509EncodedKeySpec(
				new BASE64Decoder().decodeBuffer(this._key));

		KeyFactory factory = KeyFactory.getInstance(&amp;quot;RSA&amp;quot;);
		RSAPublicKey publicKey = (RSAPublicKey) factory
				.generatePublic(spec);
		enCipher.init(Cipher.ENCRYPT_MODE, publicKey);
	}
}
	break;
}
		this._encryptProvider = enCipher;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码核心就是将其它密钥格式转换成&lt;code&gt;.pem&lt;/code&gt;格式，和&lt;code&gt;php&lt;/code&gt;后台那边适配。&lt;/p&gt;

&lt;h3 id=&#34;web&#34;&gt;web&lt;/h3&gt;

&lt;p&gt;由于是前端，所以只做加密数据。然后必须先将密钥对 ’分解‘，成 ’n‘ , &amp;rsquo;d&amp;rsquo; , &amp;lsquo;e&amp;rsquo;。上代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;JavaScript RSA Encryption &amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
 
&amp;lt;script language=&amp;quot;JavaScript&amp;quot; type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./js/jsbn.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script language=&amp;quot;JavaScript&amp;quot; type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./js/prng4.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script language=&amp;quot;JavaScript&amp;quot; type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./js/rng.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script language=&amp;quot;JavaScript&amp;quot; type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./js/rsa.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script language=&amp;quot;JavaScript&amp;quot; type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./js/base64.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script language=&amp;quot;JavaScript&amp;quot;&amp;gt; 
//publc key  and public length hex data
var public_key=&amp;quot;b3a55f5100b87959ef1bd60508fca4f547af9a0617e8eea1a69a9f7f3f669ee01d89033a7521fa25c6437c6e4c4e0237afc23dbc3f1597b3a0a2181b45aae5effbb787cf6ced26fc042168bad462d916323246ce923c6fa22b6baf62f2a8f93a753b21b3fcd4c5789d89ca02badb88081452a5ecc12d88374475bfa409627e9014600d1b821b76b8b44e6d43bf28eb9fbb68a7b40e5c778d8ff63798764277c040432b9b27a682c8e1c202e95e8c3b826d5188c389716bb4a7278761a7b22ff39ede130c1b9022449f190a79846ea616fec3e1056e8f24a7b3b508ca734ea2c8a92f2c97adc4afd391a52e04504fd69553b4e048650a44ebdaa889701256d315&amp;quot;;
var public_length=&amp;quot;0010001&amp;quot;;
function do_encrypt() {
  var before = new Date();
  var rsa = new RSAKey();
  rsa.setPublic(public_key, public_length);
  var res = rsa.encrypt(document.rsatest.plaintext.value);
  var after = new Date();
  if(res) {
    document.rsatest.ciphertext.value =res;
    document.rsatest.cipherb64.value = hex2b64(res);
    document.rsatest.status.value = &amp;quot;Time: &amp;quot; + (after - before) + &amp;quot;ms&amp;quot;;
  }
}

&amp;lt;/script&amp;gt;
 
&amp;lt;form name=&amp;quot;rsatest&amp;quot; action=&amp;quot;rsa.php&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
Plaintext (string):&amp;lt;br&amp;gt;
&amp;lt;input name=&amp;quot;plaintext&amp;quot; type=&amp;quot;text&amp;quot; value=&amp;quot;test&amp;quot; size=40&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;encrypt&amp;quot; onClick=&amp;quot;do_encrypt();&amp;quot;&amp;gt;&amp;lt;p&amp;gt;
Ciphertext (hex):(Not used)&amp;lt;br&amp;gt;
&amp;lt;textarea name=&amp;quot;ciphertext&amp;quot; rows=4 cols=70&amp;gt;&amp;lt;/textarea&amp;gt;&amp;lt;p&amp;gt;
Ciphertext (base64):&amp;lt;br&amp;gt;
&amp;lt;textarea name=&amp;quot;cipherb64&amp;quot; rows=3 cols=70&amp;gt;&amp;lt;/textarea&amp;gt;&amp;lt;p&amp;gt;
Status:&amp;lt;br&amp;gt;
&amp;lt;input name=&amp;quot;status&amp;quot; type=&amp;quot;text&amp;quot; size=40&amp;gt;&amp;lt;p&amp;gt;
&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;submit&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
  &amp;lt;body&amp;gt;
&amp;lt;html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;对应的php后台解密&#34;&gt;对应的php后台解密：&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php 
//header(&amp;quot;Content-type:text/javascript;charset=utf-8&amp;quot;);
$encrypted=$_POST[&#39;cipherb64&#39;];
$public_key = file_get_contents(&amp;quot;../public.crt&amp;quot;);
$private_key = file_get_contents(&amp;quot;../private.pem&amp;quot;);

//var_dump(base64_decode($encrypted));

$pu_key = openssl_pkey_get_public($public_key);//这个函数可用来判断公钥是否是可用的
$pi_key = openssl_pkey_get_private($private_key);//这个函数可用来判断私钥是否是可用的，可用返回资源id Resource id
//var_dump($pu_key);
//var_dump($pi_key);
openssl_private_decrypt(base64_decode($encrypted),$decrypted,$pi_key);//私钥解密
echo &amp;quot;\n&amp;quot;;
var_dump($decrypted);
echo &amp;quot;\n&amp;quot;.&amp;quot;共&amp;quot;.strlen($decrypted).&amp;quot;个字节。&amp;quot;;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;源代码分享&#34;&gt;源代码分享&lt;/h3&gt;

&lt;p&gt;以上全部代码在我的 Github 托管。&lt;a href=&#34;https://github.com/ZetaoYang/RSA&#34;&gt;传送门&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在 Alpine Linux 上编译 Linux0.11 内核</title>
      <link>https://zetaoyang.github.io/post/post-04/</link>
      <pubDate>Sat, 10 Oct 2015 10:48:19 +0800</pubDate>
      
      <guid>https://zetaoyang.github.io/post/post-04/</guid>
      <description>&lt;p&gt;近日，想在 Windows 系统下编译 Linux-0.11 内核。 于是就在 VirtualBox 中安装了 &lt;a href=&#34;http://alpinelinux.org/&#34;&gt;Alpine Linux&lt;/a&gt; 3.4 。&lt;br /&gt;
  其中 VirtualBox 下的网络配置如下：&lt;br /&gt;
使用2块网卡，第一块设置为&lt;code&gt;host-only&lt;/code&gt;方式：&lt;br /&gt;
&lt;img src=&#34;https://cdn.rawgit.com/qanno/qanno.github.io/master/images/vbox-network-1.png&#34; alt=&#34;vbox-network-1.png&#34; /&gt;&lt;br /&gt;
  第二块设置为nat 方式：
&lt;img src=&#34;https://cdn.rawgit.com/qanno/qanno.github.io/master/images/vbox-network-2.png&#34; alt=&#34;vbox-network-2.png&#34; /&gt;&lt;br /&gt;
  其中，VirtualBox Host-Only Ethernet Adapter的配置如下：&lt;br /&gt;
&lt;img src=&#34;https://cdn.rawgit.com/qanno/qanno.github.io/master/images/vbox-hostonly.png&#34; alt=&#34;vbox-hostonly.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cdn.rawgit.com/qanno/qanno.github.io/master/images/vbox-hostonly-ipv4.png&#34; alt=&#34;vbox-hostonly-ipv4.png&#34; /&gt;&lt;br /&gt;
  其中,DNS服务器地址设置和本地上网的设置相同.IP地址是自动生成，也可手动修改。这里我使用的是阿里的公共DNS。&lt;br /&gt;
  然后登陆 Alpine Linux ，查看MAC地址是否和在VirtualBox 中网络设置中的MAC地址一样。
&lt;img src=&#34;https://cdn.rawgit.com/qanno/qanno.github.io/master/images/alpine-network.png&#34; alt=&#34;alpine-network.png&#34; /&gt;&lt;br /&gt;
  这样主机和虚拟机就可以互ping，主机还可通过ssh连接虚拟机。例如：&lt;code&gt;ssh root@192.168.56.101&lt;/code&gt;   (ps.我用的是&lt;a href=&#34;http://cmder.net/&#34;&gt;cmder&lt;/a&gt;上的ssh工具)。&lt;br /&gt;
&amp;gt;推荐： 在Windows上可以用 &lt;a href=&#34;http://www.wm.edu/offices/it/services/software/licensedsoftware/webeditingsftp/sshsecureshell/index.php&#34;&gt;SSH Secure Shell Client&lt;/a&gt; 这个工具替代&lt;code&gt;scp&lt;/code&gt;命令在主机和虚拟机之间传输文件。&lt;br /&gt;
   &lt;img src=&#34;https://cdn.rawgit.com/qanno/qanno.github.io/master/images/SSHSecureShellClient.png&#34; alt=&#34;SSHSecureShellClient.png&#34; /&gt;&lt;br /&gt;
  到这儿，都是些准备工作，接下来才是本文要说的东西。&lt;br /&gt;
由于 linux 0.11(原版)内核编译需要 gcc3.4.6 ,而这个 gcc 版本太老了。于是就出现了 linux 0.11-gcc4 这个版本(网上可以搜到),可以用 gcc4.x 去编译。在我的Linux Mint 18 上，修改了几个错误之后，用自带的gcc5.4.0 编译成功了（此处为我修改的&lt;a href=&#34;https://cdn.rawgit.com/qanno/qanno.github.io/master/downloads/linux-gcc5.4.0.zip&#34;&gt;源码&lt;/a&gt;，如果还有错误编译不通过，请参考&lt;a href=&#34;http://www.voidcn.com/blog/hjq842382134/article/p-5955492.html&#34;&gt;这篇文章&lt;/a&gt;），我不甘心，我想用更高的 gcc 版本去完成这件事。在 Gihub 上search了一番，发现了这个：&lt;a href=&#34;https://github.com/yuanxinyu/Linux-0.11&#34;&gt;Linux-0.11&lt;/a&gt;，这个修改版我终于在 Alpine Linux 上编译成功了（如果遇到： &amp;ldquo;make: execvp: /tools/build.sh Permission denied .&amp;rdquo; 请修改build.sh的权限。）。
  最后，用 &lt;a href=&#34;http://bochs.sourceforge.net&#34;&gt;bochs&lt;/a&gt; 模拟启动成功了。&lt;br /&gt;
  &lt;img src=&#34;https://cdn.rawgit.com/qanno/qanno.github.io/master/images/bochs-linux0.11.png&#34; alt=&#34;bochs-linux0.11.png&#34; /&gt;
其中bochs的bxrc文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#BIOS映像文件和VGA BIOS映像文件
#XXX为Bochs的安装盘
romimage: file=XXX:\Bochs-2.6.8\BIOS-bochs-latest
#运行内存
megs: 64
vgaromimage: file=XXX:\Bochs-2.6.8\VGABIOS-lgpl-latest
#这个是启动软盘
floppya: 1_44=C:\Users\xxxx\Desktop\Image,status=inserted
ata0-master: type=disk, path=&amp;quot;C:\Users\xxxx\Desktop\linux_0_11-master\hdc-0.11.img&amp;quot;, mode=flat, cylinders=204, heads=16, spt=38
#确定启动方式
boot: c
log: C:\Users\xxxx\Desktop\bochsout.txt
cpu: count=1, ips=1000000
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>