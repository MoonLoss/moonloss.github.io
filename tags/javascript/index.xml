<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on True Me </title>
    <link>https://zetaoyang.github.io/tags/javascript/</link>
    <description>Recent content in Javascript on True Me </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Zetao的小站</copyright>
    <lastBuildDate>Sat, 08 Oct 2016 11:04:19 +0800</lastBuildDate>
    <atom:link href="https://zetaoyang.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>用Github API 上传文件的方法</title>
      <link>https://zetaoyang.github.io/post/post-01/</link>
      <pubDate>Sat, 08 Oct 2016 11:04:19 +0800</pubDate>
      
      <guid>https://zetaoyang.github.io/post/post-01/</guid>
      <description>&lt;p&gt;前几天，在V2EX看见有人用Github API基于python实现了一个图床。于是我决定用nodejs也实现一个类似功能。首先我看有没现成的第三方库，在 &lt;a href=&#34;https://developer.github.com/libraries/&#34;&gt;Libraries | GitHub Developer Guide&lt;/a&gt; 我发现有5个跟javascript相关的库：&lt;br /&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://cdn.rawgit.com/qanno/qanno.github.io/master/images/github-api-js.png&#34; alt=&#34;github-api-js.jpg&#34; /&gt;&lt;br /&gt;
&lt;/div&gt;
经调研发现 &lt;a href=&#34;https://github.com/michael/github&#34;&gt;GitHub.js wrapper around the GitHub API&lt;/a&gt; 比较好入手，基本将Github API 全都实现了，并且封装了自己的接口，但是缺点还是有的，文档写的不太详细。然后就开始看它的文档，其中Repository的writeFile()方法就是上传文件的函数。&lt;br /&gt;
其中writeFile():&lt;br /&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://cdn.rawgit.com/qanno/qanno.github.io/master/images/github-api-writeFile-2.3.0.png&#34; alt=&#34;github-api-writeFile-2.3.0.png&#34; /&gt;&lt;br /&gt;
&lt;/div&gt;&lt;br /&gt;
　　 先在这里贴出代码(ECMAScript 2015标准)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//导入github-api
var GitHub = require(&amp;quot;github-api&amp;quot;)
var fs = require(&amp;quot;fs&amp;quot;)

const gh = new GitHub({
	token: &#39;&amp;lt;your personal token&amp;gt;&#39;//这里采用token认证
})

var branch = &#39;&amp;lt;branch_name&amp;gt;&#39;//eg. master
var ufilePath = &#39;&amp;lt;repo_path&amp;gt;&#39;//eg. images/
//{master}/xxx.jpg
var ufileName = &#39;&amp;lt;file_name&amp;gt;&#39;//eg. xxx.jpg
var commit = &#39;here i am&#39;
var user = &#39;&amp;lt;user name&amp;gt;&#39;//用户名
var repo = &#39;&amp;lt;repository name&amp;gt;&#39;//仓库名

const re = gh.getRepo(user,repo)

//同步读取文件
var imageBlob = fs.readFileSync(&#39;&amp;lt;filepath&amp;gt;&#39;)
//base64编码
var imageB64 = imageBlob.toString(&#39;base64&#39;)
//ascii编码
//utf8编码也可以，只不过有些浪费。
var data = imageB64.toString(&#39;ascii&#39;)

var options = {
    //author:{},
    //commiter:{},
    encode: false
}

re.writeFile(branch, ufilePath + ufileName, data , commit,options, (error,result,request)=&amp;gt;{
    if (error===null) {	console.log(`https://cdn.rawgit.com/${user}/${repo}/${branch}/${ufilePath}${ufileName}`)
	 }
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　 这其中的关键就是编码问题， GitHub Contents API 要求content是base64编码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>非对称加密(RSA)数据传送的实战</title>
      <link>https://zetaoyang.github.io/post/post-03/</link>
      <pubDate>Thu, 06 Oct 2016 21:24:17 +0800</pubDate>
      
      <guid>https://zetaoyang.github.io/post/post-03/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;建议先了解一下RSA原理，再看本文。推荐阮一峰老师的两篇文章：
* &lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&#34;&gt;RSA算法原理（一）&lt;/a&gt;&lt;br /&gt;
* &lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html&#34;&gt;RSA算法原理（二）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为&lt;code&gt;php&lt;/code&gt;支持的密钥格式是&lt;code&gt;.pem&lt;/code&gt;所以&lt;code&gt;web&lt;/code&gt;和&lt;code&gt;java&lt;/code&gt;端都要将&lt;code&gt;pem&lt;/code&gt;格式转换成其语言平台支持的格式。 比如，&lt;code&gt;java&lt;/code&gt;支持的格式默认是&lt;code&gt;.asn&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;密钥对的生成-php&#34;&gt;密钥对的生成(php)&lt;/h3&gt;

&lt;p&gt;如果系统是&lt;code&gt;Linux&lt;/code&gt;的话，可以使用&lt;code&gt;openssl&lt;/code&gt;命令来生成。这里展示的是在&lt;code&gt;Windows&lt;/code&gt;系统下的操作(因为当时做这个东西的时候是在Windows 8.1系统下完成的)，使用 &lt;a href=&#34;https://www.apachefriends.org/zh_cn/index.html&#34;&gt;xampp&lt;/a&gt; 集成好的&lt;code&gt;openssl&lt;/code&gt;(其配置文件路径在xampp的安装路径下的php\extras\openssl\openssl.cnf，我们这次使用的就是这个文件)，下面展示用&lt;code&gt;php&lt;/code&gt;来生成密钥对：(n和e组成公钥，n和d组成私钥)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
//OPENSSL_CNF为 openssl.cnf 的路径
define(&#39;OPENSSL_CNF&#39;,&#39;&amp;lt;your openssl.cnf path &amp;gt;&#39;);
define(&#39;SHA&#39;,&amp;quot;sha512&amp;quot;);
define(&#39;LENGTH&#39;,2048);

header(&amp;quot;Content-type:text/html;charset=utf-8&amp;quot;);
$configargs=array(
	&#39;config&#39;=&amp;gt; OPENSSL_CNF,
	&amp;quot;digest_alg&amp;quot; =&amp;gt; SHA,
    &amp;quot;private_key_bits&amp;quot; =&amp;gt; LENGTH,
    &amp;quot;private_key_type&amp;quot; =&amp;gt; OPENSSL_KEYTYPE_RSA,);
$res=openssl_pkey_new($configargs);
openssl_pkey_export($res,$pri,null, $configargs);

/*Binary Data to Decimal Data
 * @param string $data
 * @return string $result
 * */
function hexTobin($hexString) 
    { 
        $hexLenght = strlen($hexString); 
        // only hexadecimal numbers is allowed 
        if ($hexLenght % 2 != 0 || preg_match(&amp;quot;/[^\da-fA-F]/&amp;quot;,$hexString)) return FALSE; 

        unset($binString); 
        for ($x = 1; $x &amp;lt;= $hexLenght/2; $x++) 
        { 
                $binString .= chr(hexdec(substr($hexString,2 * $x - 2,2))); 
        } 

        return $binString; 
    } 
 
/* Binary Data to Decimal Data
 * @param string $data
 * @return string $result
 **/
function binTodec($data)
	{
		$base = &amp;quot;256&amp;quot;;
		$radix = &amp;quot;1&amp;quot;;
		$result = &amp;quot;0&amp;quot;;

		for($i = strlen($data) - 1; $i &amp;gt;= 0; $i--)
		{
			$digit = ord($data{$i});
			$part_res = bcmul($digit, $radix);
			$result = bcadd($result, $part_res);
			$radix = bcmul($radix, $base);
		}

		return $result;
	}

$details=openssl_pkey_get_details($res);

$n_hex=bin2hex($details[&#39;rsa&#39;][&#39;n&#39;]);
$d_hex=bin2hex($details[&#39;rsa&#39;][&#39;d&#39;]);
$e_hex=bin2hex($details[&#39;rsa&#39;][&#39;e&#39;]);

$n_dec=binTodec($details[&#39;rsa&#39;][&#39;n&#39;]);
$d_dec=binTodec($details[&#39;rsa&#39;][&#39;d&#39;]);
$e_dec=binTodec($details[&#39;rsa&#39;][&#39;e&#39;]);

openssl_pkey_free($res);

$pub=$details[&#39;key&#39;];

$crtpath = &amp;quot;./test.crt&amp;quot;; //公钥文件路径  
$pempath = &amp;quot;./test.pem&amp;quot;; //私钥文件路径  

$n_hexpath = &amp;quot;./n_hex.key&amp;quot;; //n_hex文件路径  
$d_hexpath = &amp;quot;./d_hex.key&amp;quot;; //d_hex文件路径  
$e_hexpath = &amp;quot;./e_hex.key&amp;quot;; //e_hex文件路径 

$n_decpath = &amp;quot;./n_dec.key&amp;quot;; //n_dec文件路径  
$d_decpath = &amp;quot;./d_dec.key&amp;quot;; //d_dec文件路径  
$e_decpath = &amp;quot;./e_dec.key&amp;quot;; //e_dec文件路径 

//生成证书文件  
$fp = fopen($crtpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $pub);  
fclose($fp);  

$fp = fopen($pempath, &amp;quot;w&amp;quot;);  
fwrite($fp, $pri);  
fclose($fp);  
//生成n_hex,d_hex,e_hex文件
$fp = fopen($n_hexpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $n_hex);  
fclose($fp);  

$fp = fopen($d_hexpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $d_hex);  
fclose($fp);  

$fp = fopen($e_hexpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $e_hex);  
fclose($fp); 
//生成n_dec,d_dec,e_dec文件
$fp = fopen($n_decpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $n_dec);  
fclose($fp);  

$fp = fopen($d_decpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $d_dec);  
fclose($fp);  

$fp = fopen($e_decpath, &amp;quot;w&amp;quot;);  
fwrite($fp, $e_dec);  
fclose($fp); 

var_dump($pub);
echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;
var_dump($pri);
$pu_key = openssl_pkey_get_public($pub);
print_r($pu_key);
echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;
$data = &#39;plaintext data goes here.&#39;;

// Encrypt the data to $encrypted using the public key
openssl_public_encrypt($data, $encrypted,$pub,OPENSSL_PKCS1_PADDING);

// Decrypt the data using the private key and store the results in $decrypted
openssl_private_decrypt($encrypted, $decrypted, $pri,OPENSSL_PKCS1_PADDING);

echo $encrypted.&amp;quot; &amp;quot;.strlen($encrypted).&amp;quot;   &amp;quot;.base64_encode($encrypted).&amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;
echo $decrypted;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;java&#34;&gt;java&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;此处的核心代码是我从互联网上搜索到的，出处已经记不清是哪了，还请原作者见谅。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;pre&gt;&lt;code&gt;
package org.aisharing.rsa.data;&lt;/p&gt;

&lt;p&gt;import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;&lt;/p&gt;

&lt;p&gt;import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.xml.parsers.ParserConfigurationException;&lt;/p&gt;

&lt;p&gt;import org.aisharing.rsa.format.KeyFormat;
import org.xml.sax.SAXException;&lt;/p&gt;

&lt;p&gt;import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;&lt;/p&gt;

&lt;p&gt;@SuppressWarnings(&amp;ldquo;restriction&amp;rdquo;)
public class KeyWorker {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private String _key;
private KeyFormat _format;
private Cipher _decryptProvider;
private Cipher _encryptProvider;

public KeyWorker(String key) {
    this(key, KeyFormat.ASN);
}

public KeyWorker(String key, KeyFormat format) {
    this._key = key;
    this._format = format;
}

public String encrypt(String data) throws IllegalBlockSizeException,
BadPaddingException, InvalidKeyException, NoSuchAlgorithmException,
NoSuchPaddingException, InvalidKeySpecException, IOException, SAXException, ParserConfigurationException {
    this._makesureEncryptProvider();
    byte[] bytes = data.getBytes(&amp;quot;UTF-8&amp;quot;);
    bytes = this._encryptProvider.doFinal(bytes);
    return new BASE64Encoder().encode(bytes);
}

public String decrypt(String data) throws IOException,
IllegalBlockSizeException, BadPaddingException,
InvalidKeyException, NoSuchAlgorithmException,
NoSuchPaddingException, InvalidKeySpecException, SAXException, ParserConfigurationException {
    this._makesureDecryptProvider();

    byte[] bytes = new BASE64Decoder().decodeBuffer(data);
    bytes = this._decryptProvider.doFinal(bytes);
    return new String(bytes, &amp;quot;UTF-8&amp;quot;);
}

private void _makesureDecryptProvider() throws NoSuchAlgorithmException,
NoSuchPaddingException, IOException, InvalidKeySpecException,
InvalidKeyException, SAXException, ParserConfigurationException {
if (this._decryptProvider != null)
    return;

Cipher deCipher = Cipher.getInstance(&amp;quot;RSA/ECB/PKCS1Padding&amp;quot;);
switch (this._format) {

case PEM: {
    this._key = this._key.replace(&amp;quot;-----BEGIN PUBLIC KEY-----&amp;quot;, &amp;quot;&amp;quot;)
            .replace(&amp;quot;-----END PUBLIC KEY-----&amp;quot;, &amp;quot;&amp;quot;)
            .replace(&amp;quot;-----BEGIN PRIVATE KEY-----&amp;quot;, &amp;quot;&amp;quot;)
            .replace(&amp;quot;-----END PRIVATE KEY-----&amp;quot;, &amp;quot;&amp;quot;)
            .replaceAll(&amp;quot;\r\n&amp;quot;, &amp;quot;&amp;quot;);
}
case ASN:
default: {
    Boolean isPrivate = this._key.length() &amp;gt; 500;
    if (isPrivate) {
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(
                new BASE64Decoder().decodeBuffer(this._key));

        KeyFactory factory = KeyFactory.getInstance(&amp;quot;RSA&amp;quot;);
        RSAPrivateKey privateKey = (RSAPrivateKey) factory
                .generatePrivate(spec);
        deCipher.init(Cipher.DECRYPT_MODE, privateKey);
    } else {
        X509EncodedKeySpec spec = new X509EncodedKeySpec(
                new BASE64Decoder().decodeBuffer(this._key));

        KeyFactory factory = KeyFactory.getInstance(&amp;quot;RSA&amp;quot;);
        RSAPublicKey publicKey = (RSAPublicKey) factory
                .generatePublic(spec);
        deCipher.init(Cipher.DECRYPT_MODE, publicKey);
    }
}
    break;
}

this._decryptProvider = deCipher;
}


private void _makesureEncryptProvider() throws NoSuchAlgorithmException,
NoSuchPaddingException, IOException, InvalidKeySpecException,
InvalidKeyException, SAXException, ParserConfigurationException {
if (this._encryptProvider != null)
    return;

Cipher enCipher = Cipher.getInstance(&amp;quot;RSA/ECB/PKCS1Padding&amp;quot;);
switch (this._format) {

case PEM: {
    this._key = this._key.replace(&amp;quot;-----BEGIN PUBLIC KEY-----&amp;quot;, &amp;quot;&amp;quot;)
            .replace(&amp;quot;-----END PUBLIC KEY-----&amp;quot;, &amp;quot;&amp;quot;)
            .replace(&amp;quot;-----BEGIN PRIVATE KEY-----&amp;quot;, &amp;quot;&amp;quot;)
            .replace(&amp;quot;-----END PRIVATE KEY-----&amp;quot;, &amp;quot;&amp;quot;)
            .replaceAll(&amp;quot;\r\n&amp;quot;, &amp;quot;&amp;quot;);
}
case ASN:
default: {
    Boolean isPrivate = this._key.length() &amp;gt; 500;
    if (isPrivate) {
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(
                new BASE64Decoder().decodeBuffer(this._key));

        KeyFactory factory = KeyFactory.getInstance(&amp;quot;RSA&amp;quot;);
        RSAPrivateKey privateKey = (RSAPrivateKey) factory
                .generatePrivate(spec);
        enCipher.init(Cipher.ENCRYPT_MODE, privateKey);

    } else {
        X509EncodedKeySpec spec = new X509EncodedKeySpec(
                new BASE64Decoder().decodeBuffer(this._key));

        KeyFactory factory = KeyFactory.getInstance(&amp;quot;RSA&amp;quot;);
        RSAPublicKey publicKey = (RSAPublicKey) factory
                .generatePublic(spec);
        enCipher.init(Cipher.ENCRYPT_MODE, publicKey);
    }
}
    break;
}

        this._encryptProvider = enCipher;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/code&gt;&lt;/pre&gt;
以上代码核心就是将其它密钥格式转换成&lt;code&gt;.pem&lt;/code&gt;格式，和&lt;code&gt;php&lt;/code&gt;后台那边适配。&lt;/p&gt;

&lt;h3 id=&#34;web&#34;&gt;web&lt;/h3&gt;

&lt;p&gt;由于是前端，所以只做加密数据。然后必须先将密钥对 ’分解‘，成 ’n‘ , &amp;rsquo;d&amp;rsquo; , &amp;lsquo;e&amp;rsquo;。上代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;JavaScript RSA Encryption &amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
 
&amp;lt;script language=&amp;quot;JavaScript&amp;quot; type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./js/jsbn.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script language=&amp;quot;JavaScript&amp;quot; type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./js/prng4.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script language=&amp;quot;JavaScript&amp;quot; type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./js/rng.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script language=&amp;quot;JavaScript&amp;quot; type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./js/rsa.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script language=&amp;quot;JavaScript&amp;quot; type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./js/base64.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script language=&amp;quot;JavaScript&amp;quot;&amp;gt; 
//publc key  and public length hex data
var public_key=&amp;quot;b3a55f5100b87959ef1bd60508fca4f547af9a0617e8eea1a69a9f7f3f669ee01d89033a7521fa25c6437c6e4c4e0237afc23dbc3f1597b3a0a2181b45aae5effbb787cf6ced26fc042168bad462d916323246ce923c6fa22b6baf62f2a8f93a753b21b3fcd4c5789d89ca02badb88081452a5ecc12d88374475bfa409627e9014600d1b821b76b8b44e6d43bf28eb9fbb68a7b40e5c778d8ff63798764277c040432b9b27a682c8e1c202e95e8c3b826d5188c389716bb4a7278761a7b22ff39ede130c1b9022449f190a79846ea616fec3e1056e8f24a7b3b508ca734ea2c8a92f2c97adc4afd391a52e04504fd69553b4e048650a44ebdaa889701256d315&amp;quot;;
var public_length=&amp;quot;0010001&amp;quot;;
function do_encrypt() {
  var before = new Date();
  var rsa = new RSAKey();
  rsa.setPublic(public_key, public_length);
  var res = rsa.encrypt(document.rsatest.plaintext.value);
  var after = new Date();
  if(res) {
    document.rsatest.ciphertext.value =res;
    document.rsatest.cipherb64.value = hex2b64(res);
    document.rsatest.status.value = &amp;quot;Time: &amp;quot; + (after - before) + &amp;quot;ms&amp;quot;;
  }
}

&amp;lt;/script&amp;gt;
 
&amp;lt;form name=&amp;quot;rsatest&amp;quot; action=&amp;quot;rsa.php&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
Plaintext (string):&amp;lt;br&amp;gt;
&amp;lt;input name=&amp;quot;plaintext&amp;quot; type=&amp;quot;text&amp;quot; value=&amp;quot;test&amp;quot; size=40&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;encrypt&amp;quot; onClick=&amp;quot;do_encrypt();&amp;quot;&amp;gt;&amp;lt;p&amp;gt;
Ciphertext (hex):(Not used)&amp;lt;br&amp;gt;
&amp;lt;textarea name=&amp;quot;ciphertext&amp;quot; rows=4 cols=70&amp;gt;&amp;lt;/textarea&amp;gt;&amp;lt;p&amp;gt;
Ciphertext (base64):&amp;lt;br&amp;gt;
&amp;lt;textarea name=&amp;quot;cipherb64&amp;quot; rows=3 cols=70&amp;gt;&amp;lt;/textarea&amp;gt;&amp;lt;p&amp;gt;
Status:&amp;lt;br&amp;gt;
&amp;lt;input name=&amp;quot;status&amp;quot; type=&amp;quot;text&amp;quot; size=40&amp;gt;&amp;lt;p&amp;gt;
&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;submit&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
  &amp;lt;body&amp;gt;
&amp;lt;html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;对应的php后台解密&#34;&gt;对应的php后台解密：&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php 
//header(&amp;quot;Content-type:text/javascript;charset=utf-8&amp;quot;);
$encrypted=$_POST[&#39;cipherb64&#39;];
$public_key = file_get_contents(&amp;quot;../public.crt&amp;quot;);
$private_key = file_get_contents(&amp;quot;../private.pem&amp;quot;);

//var_dump(base64_decode($encrypted));

$pu_key = openssl_pkey_get_public($public_key);//这个函数可用来判断公钥是否是可用的
$pi_key = openssl_pkey_get_private($private_key);//这个函数可用来判断私钥是否是可用的，可用返回资源id Resource id
//var_dump($pu_key);
//var_dump($pi_key);
openssl_private_decrypt(base64_decode($encrypted),$decrypted,$pi_key);//私钥解密
echo &amp;quot;\n&amp;quot;;
var_dump($decrypted);
echo &amp;quot;\n&amp;quot;.&amp;quot;共&amp;quot;.strlen($decrypted).&amp;quot;个字节。&amp;quot;;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;源代码分享&#34;&gt;源代码分享&lt;/h3&gt;

&lt;p&gt;以上全部代码在我的 Github 托管。&lt;a href=&#34;https://github.com/ZetaoYang/RSA&#34;&gt;传送门&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>