[{"content":"\n\n在这个知识经济时代，如何把有用的信息、知识构建起来，形成一套自己的知识系统？这篇文章将会提供一种我的做法。\n\n首先我记录的载体都是一些纯文本，比如 markdown 或者 text。markdown 的编辑器是 [typora](https://www.typora.io) (P.S. 顺便说一下，Linux 版可以不按官网所说的那样做，直接打开 https://www.typora.io/linux/typora_0.9.40_amd64.deb 下载 安装 `.deb` 即可。0.9.40 是目前 Linux 上最新的版本号)。\n\n笔记目录安排如下(参考自知乎 [**INK笔记法**](https://www.zhihu.com/question/23427617))：\n\n- **Inbox**（收集）\n- **Note**（储存）\n- **Knowledge**（知识）\n\n\n只要在 typora 中点击 文件→打开文件夹。添加笔记所在目录即可。typora 会记住最近使用的目录，下次重新打开也很方便，就在左下栏：\n\n![lower-left-column](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/lower-left-column.png)\n\n![recent folder](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/recent-folder.png)\n\n这样，编辑这部分就搭好了，效果就是这样：\n\n![typora editor](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/rclone-typora-editor.png)\n\n接下来就是存储这块。\n\n存储，我采用同步盘，存在 Onedrive 上，毕竟有 1TB 空间。Windows 自然是用它的客户端了，还支持[文件按需](https://aka.ms/vog6zj)下载。在 linux 上有很多开源的 onedrive 同步盘，但他们使用上都不是很理想，故不推荐，如有兴趣，可自行尝试，有问题，我们可以在讨论区讨论。我认为最好的两种途径就是: \n\n- [goodsync](https://www.goodsync.com)   双向同步 ；[linux 版](https://www.goodsync.com/for-linux)仅命令行版； free 版有限制，具体看 [free-vs-pro](https://www.goodsync.com/free-vs-pro) ；还有算不上缺点的缺点：它会在同步的目录下生成 隐藏目录`_gsdata_`，goodsync 就是依靠这个目录来双向同步的，所以此目录不要自己随意删除。\n- [rclone](https://rclone.org)   单向同步；\n\n我要介绍的就是 rclone 以及我改造后的 bash 脚本。\n\npull.sh： (remote =\u003e local)\n\n```shell\n#! /bin/bash\n\n#########################################\n#\n#  rclone sync script\n#   remote =\u003e local\n#\n#########################################\n\n#pull_command=`~/Tools/Daily/rclone/rclone sync Goupgq-OneDrive:/Notes ~/Documents/OneDrive/Notes --stats-log-level NOTICE 2\u003e\u00261 |grep -n 'Errors'`\n\n`~/Tools/Daily/rclone/rclone sync Goupgq-OneDrive:/Notes ~/Documents/OneDrive/Notes --dry-run --stats-log-level NOTICE`\n\necho -e \"\\033[46;37m remote =\u003e local \\033[0m\" #sky blue backgroud and white word\necho -e \"\\033[41;37m If -yes Local files will be change! \\033[0m\" #red backgroud and white word\n\nread -r -p \"Are you sure? [y/N] \" response\ncase \"$response\" in\n    [yY][eE][sS]|[yY]) \n\n        pull_command=`~/Tools/Daily/rclone/rclone sync Goupgq-OneDrive:/Notes ~/Documents/OneDrive/Notes --stats-log-level NOTICE 2\u003e\u00261 |grep -E 'Errors|Transferred'`\n\n        transferred_content=${pull_command#'Transferred:'*}\n        transferred_size=${transferred_content%%'Bytes'*}\n        #echo ${transferred_content}\n\n        errors=${pull_command#*'Errors:'}\n        errors_num=${errors%T*}\n        transferred_num=${pull_command##*'Transferred:'}\n\n        #echo ${errors_num}\n        #echo ${transferred_num}\n\n        if [ $errors_num -ne \"0\" ]; then\n            notify-send -t 1500 \"Failed!\"\n        else   \n            notify-send -t 1500 \"Successful!\" \"Num:${transferred_num// /} ❤️ Size:${transferred_size// /}B\"\n\n        fi\n\n        ;;\n    *)\n         echo \"Not change.\"\n         return\n        ;;\nesac\n\n#read -p \"Press enter to continue\"\n#read -n 1 -s -r -p \"Press any key to continue\"\n```\n\n\n\npush.sh：(local =\u003e remote )\n\n```shell\n#! /bin/bash\n\n#########################################\n#\n#  rclone sync script\n#   local =\u003e remote \n#\n#########################################\n\n#push_command=`~/Tools/Daily/rclone/rclone sync ~/Documents/OneDrive/Notes Goupgq-OneDrive:/Notes --stats-log-level NOTICE 2\u003e\u00261 |grep -n 'Errors'`\n\n`~/Tools/Daily/rclone/rclone sync ~/Documents/OneDrive/Notes Goupgq-OneDrive:/Notes --dry-run --stats-log-level NOTICE`\n\necho -e \"\\033[46;37m local =\u003e remote \\033[0m\" #sky blue backgroud and white word\necho -e \"\\033[41;37m If -yes Remote files will be change! \\033[0m\" #red backgroud and white word\n\nread -r -p \"Are you sure? [y/N] \" response\ncase \"$response\" in\n    [yY][eE][sS]|[yY]) \n        \n        push_command=`~/Tools/Daily/rclone/rclone sync ~/Documents/OneDrive/Notes Goupgq-OneDrive:/Notes --stats-log-level NOTICE 2\u003e\u00261 |grep -E 'Errors|Transferred'`\n\n        #echo ${push_command}\n         \n        transferred_content=${push_command#'Transferred:'*}\n        transferred_size=${transferred_content%%'Bytes'*}\n        #echo ${transferred_size}\n\n        errors=${push_command#*'Errors:'}\n        errors_num=${errors%T*}\n        transferred_num=${push_command##*'Transferred:'}\n\n        #echo ${errors_num}\n        #echo ${transferred_num}\n\n        if [ $errors_num -ne \"0\" ]; then\n            notify-send -t 1500 \"Failed!\"\n        else\n            notify-send -t 1500 \"Successful!\" \"Num:${transferred_num// /} ❤️ Size:${transferred_size// /}B\"\n        fi\n\n        ;;\n    *)\n         echo \"Not change.\"\n         return\n        ;;\nesac\n\n#read -p \"Press enter to continue\"\n#read -n 1 -s -r -p \"Press any key to continue\"\n```\n\n注：使用前提前配置好 rclone 的远程存储。另外这里用到了一个桌面通知的库，一般 Linux 发行版都会自带，如果没有的话，那就执行`sudo apt-get install libnotify-bin` 来安装。安装之后就可以使用 notify-send 向桌面发送通知了。\n\n\n\n使用截图：\n\n![pulling](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/rclone-pull.png)\n\n![pushing](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/rclone-push.png)\n\n![the success notification of pushing](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/rclone-notification.png)\n\n\n","cover":"","link":"./post/2017/12/26/rclone-and-notes.html","preview":"\u003cp\u003e在这个知识经济时代，如何把有用的信息、知识构建起来，形成一套自己的知识系统？这篇文章将会提供一种我的做法。\u003c/p\u003e\n","title":"动手搭起属于自己的云笔记环境"},{"content":"\n\n### 前言\n\n由于 Disqus 大陆无法正常访问，所以很长一段时间我博客原生的 Disqus 评论框，只有大陆外和「掌握科学上网」技能的人，才能看见和评论。访客要留言，和我交流都得要「科学上网」吗？如果评论系统不能正常评论，那还要它干啥？后来，找到了比较好的解决之道。另外， 为什么大费周章地折腾 Disqus，而不去试试国内的类似服务呢？简单来说，还是 Disqus 可靠些，这不是崇洋媚外，事实如此。这里引用 [Jerry Qu](https://imququ.com) 的一段话：  \n\n\u003e 作为一个免费产品，如果不能找到可靠的盈利模式，什么时候停止服务就取决于老板的耐心和决心了。\n\n### 实现方法\n\n借「路」大陆外的服务器或支持 cURL 的虚拟空间(理论上，大陆内的网络大多无法直接访问 Disqus，虽然可以使用指定 IP，但访问 Disqus 的速度明显没有大陆外的主机快，所以最好是大陆外的主机)。[**disqus-php-api**](https://github.com/fooleap/disqus-php-api) 这个项目就是后端代码，项目作者选择了 PHP cURL，因为PHP 的虚拟空间好找呀。  \n\n### 后端部署\n\n[**disqus-php-api**](https://github.com/fooleap/disqus-php-api)  下`api`目录下的就是 PHP 后台代码。  \n\n```\n├─disqus-php-api\n│      demo.html\n│      gulpfile.js\n│      index.js\n│      package.json\n│      update-thread.html\n│      webpack.config.js\n│\n├─api\n│  │  cacert.pem\n│  │  config.php\n│  │  count.php\n│  │  createthread.php\n│  │  getcomments.php\n│  │  getgravatar.php\n│  │  init.php\n│  │  popular.php\n│  │  postcomment.php\n│  │  removecomment.php\n│  │  sendemail.php\n│  │  updatecomment.php\n│  │  updatethread.php\n│  │  upload.php\n│  │\n│  ├─emojione\n│  │  │  autoload.php\n│  │  │\n│  │  └─src\n│  │          Client.php\n│  │          ClientInterface.php\n│  │          Emojione.php\n│  │          Ruleset.php\n│  │          RulesetInterface.php\n│  │\n│  └─PHPMailer\n│          class.phpmailer.php\n│          class.smtp.php\n│\n├─dist\n│      eac.min.json\n│      iDisqus.min.css\n│      iDisqus.min.js\n│\n└─src\n       eac.json\n       iDisqus.js\n       iDisqus.scss\n       jsonminify\n```\n\n\n\n按照`config.php`文件里的代码注释，将相关个人 Disqus  配置信息填好。然后就直接把整个`api`文件夹拷贝到自己的境外服务器或者 PHP 虚拟空间。至此，后端就部署好了。\n\n**注**：如果使用的是虚拟 PHP 空间，此 PHP API 的 URL 可以使用虚拟空间提供的二级域名，也可以使用自己的域名，URL 的地址可以规范一下，比如：`//api.xxx.com/disqus/v1`。  \n\n### 前端使用\n\n前端需要 [**disqus-php-api**](https://github.com/fooleap/disqus-php-api) 下`dist`目录下的三个文件：`eac.min.json`(压缩的 emoji unicode 编码文件)，`iDisqus.min.css`，`iDisqus.min.js`。  \n\n主要分三步：\n\n- 引入 CSS, JS： \n\n```html\n\u003clink rel=\"stylesheet\" href=\"path/to/iDisqus.min.css\" /\u003e\n```\n\n```html\n\u003cscript src=\"path/to/iDisqus.min.js\"\u003e\u003c/script\u003e\n```\n\n- 创建容器：\n\n```html\n\u003cdiv id=\"comment\"\u003e\u003c/div\u003e\n```\n\n- 创建实例：\n\n这里贴出我的大体配置，详细如何配置参看 [README](https://github.com/fooleap/disqus-php-api/blob/master/readme.md)。\n\n```javascript\nvar disq = new iDisqus('comment', {\n    forum: 'your_disqus_short_name',\n    api: 'https://api.xxx.com/disqus/v1',\n    site: 'https://your_website.com',\n    mode: 3,\n    timeout: 3000,\n    init: true,\n    toggle: 'comment-toggle',\n    sort: 'newest',\n    emoji_preview: true,\n\tbadge: '博主'\n });\ndisq.popular();\ndisq.count();\n```\n\n\n\n对于切换评论框，具体用法是在网页中放置一个 Checkbox ：\n\n```html\n\u003cdiv class=\"comment-toggle\"\u003e \n\t\u003cinput type=\"checkbox\" id=\"comment-toggle\" class=\"comment-toggle-input\" disabled\u003e \n\t\u003clabel class=\"comment-toggle-icon\" for=\"comment-toggle\"\u003e\u003c/label\u003e \n\t\u003clabel class=\"comment-toggle-button\" for=\"comment-toggle\"\u003e评论框\u003c/label\u003e \n\u003c/div\u003e\n```\n\n\n\n**注**：这里有一个小坑，可能因人而已，才可能会遇到，就是实例创建的配置`site: 'https://your_website.com'`这一项，网址`https://your_website.com`后千万不要再加`/`，否则，切换评论框失效。这个「坑」我是看到`iDisqus.js`里的这段代码才发现的：\n\n```javascript\nvar _ = this;\nvar _tip = _.dom.querySelector('.loading-container').dataset.tip;\nif(_.opts.site != location.origin){\n//console.log('本地环境不加载 Disqus 评论框！');\nif( _.opts.mode == 1 ){\n\t_.getlist();\n }\n   return;\n}\n```\n\n看到`if(_.opts.site != location.origin)` 才恍然大悟。  \n\n最后，前端剩下的就是一些 CSS 样式的调整了。\n\n### 补充\n\n还有很多评论的系统可以参考，比如基于 Github Issues 的，如 [gitment](https://github.com/imsun/gitment)。还有一些基于 PaaS 的，例如 [Valine](https://github.com/xCss/Valine) 是一款基于 Leancloud 的极简评论系统。\n\n\n\n### 相关资料\n\n[**disqus-php-api**](https://github.com/fooleap/disqus-php-api) 作者博客：  \n\n- [Disqus 的 @ 提及功能](http://blog.fooleap.org/mention-people-on-disqus.html)   \n- [科学使用 Disqus ](http://blog.fooleap.org/use-disqus-correctly.html) \n- [像 Disqus 一样获取链接颜色 ](http://blog.fooleap.org/get-link-color-like-disqus.html) \n- [Disqus 的 URL 编码问题 ](http://blog.fooleap.org/disqus-url-encode.html) \n- [使用 Disqus API 上传图片](http://blog.fooleap.org/use-disqus-api-to-upload-image.html)  \n- [Disqus API 评论嵌套问题](http://blog.fooleap.org/disqus-api-comments-order-by-desc.html)  \n- [Disqus API 的权限问题 ](http://blog.fooleap.org/disqus-api-permissions.html) \n- [Disqus 的评论预审核 ](http://blog.fooleap.org/pre-moderation-on-disqus.html) \n- [Disqus Moderator Badge Text 已支持中文](http://blog.fooleap.org/disqus-moderator-badge-text.html)  \n\n\n\n[**disqus-php-api**](https://github.com/fooleap/disqus-php-api) DEMO 演示：\n\n- [Disqus PHP API 示例](http://blog.fooleap.org/disqus-php-api.html)  \n\n\n\n","cover":"","link":"./post/2017/10/06/regain-disqus.html","preview":"\u003cp\u003e由于 Disqus 大陆无法正常访问，所以很长一段时间我博客原生的 Disqus 评论框，只有大陆外和「掌握科学上网」技能的人，才能看见和评论。访客要留言，和我交流都得要「科学上网」吗？如果评论系统不能正常评论，那还要它干啥？后来，找到了比较好的解决之道。\u003c/p\u003e\n","title":"让 Disqus「重获新生」"},{"content":"\n\n\u003e  为什么这里没有目录呢？因为我用的静态网页生成器暂时还不支持 `[TOC]` 语法。抱歉。\n\n### 前言\n\n在使用自己的系统 (Linux Mint) 时，不由地担心万一哪天坏掉，要重装系统，这么多配置好的环境怎么恢复呀，因此整理出一篇博文记录一下自己平时常用软件以及开发环境配置，以备不时之需。另外，Linux Mint 非常适合Windows 用户过渡到 Linux。Linux Mint 虽然第一眼看到界面不怎么“美”，可越用感觉越好用。\n\n下面从 Linux Mint 18.2 安装开始说起：\n\n### tl,dr;\n\n### 安装\n\n现在的 GNU/Linux 除了纯的 Arch Linux 外，安装都很简单。所以如何安装此处略过。\n\n![首次安装后的桌面](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/desktop-1.png)\n\n接下来要特别强调一下安装完系统后该干的事。\n\n### 基本配置\n\n更换镜像源(选择你的网络环境下最快的)，安装无线网卡，显卡等驱动，安装视频解码器(P.S. 会安装 VLC)，\n\n![安装多媒体解码器](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/mutil-codecs.png)\n\n\n再安装输入法框架，比如 fcitx, ibus 等(可以命令行安装，也可以在系统设置 -\u003e 输入法 安装)，添加简体繁体中文支持(因为我安装的是英文系统)。如图：\n\n![语言设置](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/setting-language.png)\n\n安装中文输入法，比如[搜狗输入法](http://pinyin.sogou.com/linux/?r=pinyin)，[Rime](http://rime.im/download/) ，然后如下设置(再次说明，我装的是英文系统，不是中文，如果是中文就无需做此设置)。\n\n![打开 Fctix 设置](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/input-method-1.png)\n\n\n\n![添加 Sogou、Rime 输入法](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/input-method-2.png)\n\n### 美化\n\n任务栏优化，在系统设置里添加热区。\n\n安装「任务栏图标自动折叠」applet ——“[Drawer (show/hide applets)](https://cinnamon-spices.linuxmint.com/applets/view/169#)”，可以手动安装，安装解压在 `~/.cinnamon/configs` 后添加即可。也可在系统设置的 Applets 在线安装，像下图一样：\n\n![显示/隐藏 applets](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/show-hide-applets.png)\n\n\n在任务栏添加后效果如下：\n\n![任务栏图标自动隐藏](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/desktop-2.png)\n\n\n安装主题 [Numix](https://numixproject.org) 的图标集，执行：\n\n```\nsudo add-apt-repository ppa:numix/ppa\nsudo apt-get update\nsudo apt-get install numix-icon-theme-circle\n```\n\n如果还想使用Numix 的壁纸，执行：\n\n`sudo apt-get install numix-wallpaper-*`\n\n字体(P.S. Linux 下太缺少字体了)：\n\n下面是我整理出的一些字体，仅供参考：\n\n| No.  | Fonts for Linux (most only personal usage) |\n| ---- | ---------------------------------------- |\n| 1    | **[方正字体](http://shop.foundertype.com/index.php/FindFont/index.html)**     包括四种免费字体：方正黑体、方正书宋、方正仿宋、方正楷体。 |\n| 2    | **王汉宗自由字形**     由中原大學數學系王漢宗教授所研發、捐贈，採用GPL授權，免費使用。各位老師及網友，可以推廣使用。 |\n| 3    | **[文鼎公众授权字体](http://www.arphic.com.tw/zh-tw/support/index)** |\n| 4    | **[思源黑体](https://github.com/adobe-fonts/source-han-sans)**     思源黑体（英语：Source Han Sans）是Adobe与Google所领导开发的开源字体家族，1.001及更早版本以Apache 2.0许可证授权，而1.002及更新版本则使用SIL开源字体授权，属于无衬线黑体。思源黑体于2014年7月16日首次发布，支持繁体中文、简体中文、日文及韩文，并且各有7种字体粗细。公开之时为当时涵盖字元数量最多的字体，44,666个字元分属于65,535个字形中，此为OpenType字体技术的极限。 |\n| 5    | **文泉驿字体**     文泉驿是一个开源汉字字体项目，由旅美学者房骞骞（FangQ）于2004年10月创建，集中力量解决GNU/Linux高质量中文字体匮乏的状况。目前，文泉驿已经开发并发布了第一个完整覆盖GB18030汉字（包含27000多个汉字）的多规格点阵汉字字库，第一个覆盖GBK字符集的开源矢量字库（文泉驿正黑），并提供了目前包含字符数目最多的开源字体——GNU Unifont——中绝大多数中日韩文相关的符号。这些字库已经逐渐成为主流Linux/Unix发行版中文桌面的首选中文字体。目前Ubuntu、Fedora、Slackware、Magic Linux、CDLinux使用文泉驿作为默认中文字体，Debian、Gentoo、Mandriva、ArchLinux、Frugalware则提供了官方源支持，而FreeBSD则在其ports中有提供。文泉驿的网站（除了论坛）采用Wiki搭建。 |\n| 6    | **[濑户字体](https://www.justfont.com/fonts)**     字体为濑户制作的免费字体，字体包含中文繁体常用字及多国语言。 |\n| 7    | **[书体坊免费字体](http://fonts.mobanwang.com/shutifang/)**    专注于古今书法名家计算机字体开发的书体坊提供的免费字体。 |\n| 8    | **[站酷高端黑](http://www.zcool.com.cn/special/gaoduanhei/)**     “汉字百人舞”计划，由字体设计师胡晓波、刘兵克发起，在站酷网征集100位字体设计师共同完成一套字库创作，供所有人永久免费下载。 |\n| 9    | **[造字工房](http://makefont.com/fonts.html)**   有个人免费授权使用。 |\n| 10   | **[Free-Chinese-Fonts](http://zenozeng.github.io/Free-Chinese-Fonts/)** |\n| 11   | **[新蒂字体](http://www.sentyfont.com/)**    |\n| 12   | **[mononoki](https://github.com/madmalik/mononoki)**    a programming typeface. |\n| 13   | **[source code pro](https://github.com/adobe-fonts/source-code-pro)**     Monospaced font family for user interface and coding environments. |\n| 14   | **[编程等宽字体](http://blog.jobbole.com/42556/)** |\n\n(P.S. 如果是和 Windows 的双系统，当然可以把 Windows 里的字体拷贝到 Linux 里呀。)  \n\n这里贴一下我的系统字体配置方案：  \n\n![系统字体设置](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/linuxmint-system-font-setting.png)\n\n另外，对于 Chrome 浏览器字体发虚的问题，只要在`chrome://settings/fonts`里设置 `xxx CJK`字体就行了(等宽字体 monospace 默认就好，这里的 CJK 是指中日韩三国字体)。  \n\n\n\n### 软件\n\n(注：此处的软件是指非系统自带的软件)\n\nDaily：\n\n- Chrome 浏览器；\n\n- [GitKraken](https://www.gitkraken.com/)  ，需要先安装 libcurl3 的依赖；\n\n- [Typora](https://typora.io/) ；\n\n- [shadowsocks-qt](https://github.com/shadowsocks/shadowsocks-qt5) ；\n\n- [WPS Office 2016 for Linux](http://wps-community.org/downloads) (基本和MS Office 2007 差不多了)；\n\n  安装后`Some formula symbols might not be displayed correctly due to missing `字体问题解决方案：\n\n  - http://community.wps.cn/wiki/No_necessary_symbol_fonts\n  - https://github.com/so-zengtao/nginx-wps-community/tree/master/root/download/fonts\n\n- [telegram](https://telegram.org/)   亦可以用第三方 [PPA 源](https://launchpad.net/~atareao/+archive/ubuntu/telegram)安装：\n\n```\nsudo add-apt-repository ppa:atareao/telegram\nsudo apt-get update\nsudo apt-get install telegram\n```\n\n-  openvpn 客户端(CLI) `sudo apt-get install openvpn`（已经自带无需安装），再安装图形化的客户端 gopenvpn，虽然 [PPA 源](https://launchpad.net/~gopenvpn/+archive/ubuntu/gopenvpn)有，但是它不适合用 PPA 源来安装。我们可以直接从 [launchpad net](https://launchpad.net/~gopenvpn/+archive/ubuntu/gopenvpn/+sourcepub/1701862/+listing-archive-extra) 直接下载 deb 来安装，然后在`/etc/openvpn`目录下添加 xxx.ovpn 格式的配置文件。\n-  Ubuntu Cleaner  为 Ubuntu/LinuxMint 释放空间，PPA 源安装：\n\n```\nsudo add-apt-repository ppa:gerardpuig/ppa\nsudo apt update\nsudo apt install ubuntu-cleaner\n```\n\n- [Stacer](https://github.com/oguzhaninan/Stacer)  Linux System Optimizer and Monitoring  \n\n- [f.lux GUI](https://launchpad.net/~nathan-renniewaldock/+archive/ubuntu/flux)     PPA 源安装：\n\n```\nsudo add-apt-repository ppa:nathan-renniewaldock/flux\nsudo apt-get update\nsudo apt-get install fluxgui\n```\n\n- [uget](http://ugetdm.com) 下载器以及安装 aria2 插件；\n- [Persepolis](https://persepolisdm.github.io)  a Download Manager \u0026 a GUI For aria2；\n- [网易云音乐](http://music.163.com/) ；\n- [Spotify](https://www.spotify.com/jp/download/linux/)  ；\n- [FileZilla](https://filezilla-project.org/) 并配置 menu 菜单-\u003e 站点管理菜单；\n- [FF-Multi-Converter](https://github.com/Ilias95/FF-Multi-Converter)  [PPA 源](https://launchpad.net/~cteehayder/+archive/ubuntu/ffmulticonverter)；\n- [octave](https://www.gnu.org/software/octave)  类似于 Matlab\n- [Dukto](https://software.opensuse.org/download.html?project=home:colomboem\u0026package=dukto)  命令行安装：\n\n```\nsudo sh -c \"echo 'deb http://download.opensuse.org/repositories/home:/colomboem/xUbuntu_16.04/ /' \u003e /etc/apt/sources.list.d/dukto.list\"\nsudo apt-get update\nsudo apt-get install dukto\n```\n- 播客：   \n\n 1.gpodder [PPA 源](https://launchpad.net/~thp/+archive/ubuntu/gpodder)安装：\n\n```\nsudo add-apt-repository ppa:thp/gpodder\nsudo apt-get update\nsudo apt-get install gpodder\n```\n 2.[vocal](http://vocalproject.net) (很难在非 elementary OS 上安装，但是界面很漂亮) :\n\n  可以下载我重新打包的 [vocal_2.0.20-2_amd64.deb](https://github.com/needle-and-thread/vocal/files/1550662/vocal_2.0.20-2_amd64.deb.zip)  \n\n 3.[cumulonimbus](https://github.com/z------------/cumulonimbus)：\n\n   Electron 技术开发，安装包体积较大。\n\n-  [albert](https://github.com/albertlauncher/albert)  [PPA 源](https://launchpad.net/~nilarimogard/+archive/ubuntu/webupd8)安装：\n\n```\nsudo add-apt-repository ppa:nilarimogard/webupd8\nsudo apt-get update\nsudo apt-get install albert\n```\n\n- Grub Customizer 是个能修改 GRUB 的工具  [PPA 源](https://launchpad.net/~danielrichter2007/+archive/ubuntu/grub-customizer/+packages)安装：\n\n\n```\nsudo add-apt-repository ppa:danielrichter2007/grub-customizer\nsudo apt-get update\nsudo apt-get install grub-customizer\n```\n\n- 编译安装 [putty](https://www.chiark.greenend.org.uk/~sgtatham/putty/)  (依赖 GTK 库 libgtk-3-dev)  \n- 安装 [sublime](https://www.sublimetext.com) 并解决 fctix 中文无法输入的问题，参考[这儿](https://blog.waydrow.com/2015/12/07/ubuntu%E4%B8%8Bsublime-text3%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/)\n- 安装 wireshark     [PPA 源](https://launchpad.net/~wireshark-dev/+archive/ubuntu/stable)安装：\n\n\n```\nsudo add-apt-repository ppa:wireshark-dev/stable\nsudo apt-get update\nsudo apt-get install wireshark\n```\n出现\n```\nsudo wireshark\n报错信息为：\nLua: Error during loading:\n[string \"/usr/share/wireshark/init.lua\"]:45:dofile has been disabled\n```\n\n的解决办法：\n\n```\n方法一：\n编辑init.lua文件的倒数第二行：(使用命令：sudo vim /etc/wireshark/init.lua)；改为：--dofile(DATA_DIR..\"console.lua\")\n重启wireshark即可。但是这样无法使用 Lua 脚本。\n\n方法二(更好的解决方案)：\n改变/usr/share/dumpcap的group，添加一个group：wireshark，将 dumpcap 这个文件 chgrp 到 wireshark 组，再改成 4755 权限，这样方便权限控制，具体步骤如下：\n\n1、添加用户组，我以wireshark为例\nsudo groupadd wireshark\n\n2、将dumpcap更改为wireshark用户组\nsudo chgrp wireshark /usr/bin/dumpcap\n\n3、让wireshark用户组有root权限使用dumpcap\nsudo chmod 4755 /usr/bin/dumpcap\n\n4、将自己加入wireshark用户组，我的用户是yang，你添加需要更改这个。\nsudo gpasswd -a yang wireshark\n\n这样就完成，你可以使用自己的用户打开Wireshark，并且有权限进行操作了。\n注：如果 Wireshark 更新了，需要重新执行上面的 2，3 两步。\n```\n\n-  [VirtualBox](https://www.virtualbox.org/wiki/Linux_Downloads) ；\n-  安装 [texlive](https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/) 相关教程：\n  - http://www.linuxidc.com/Linux/2016-08/133913.htm\n  - http://blog.csdn.net/qq_33429968/article/details/62928742\n  - http://seisman.info/install-texlive-under-linux.html\n  - https://tieba.baidu.com/p/5164988580\n  - http://www.bagualu.net/wordpress/archives/6523\n  - http://www.peijun.me/latex-configurtion.html\n\n-  [texstudio](http://texstudio.sourceforge.net/)   (如果是 KDE 桌面环境，建议使用 [Kile](https://code.launchpad.net/~kile/+archive/ubuntu/2.1-daily/+build/8788610) )；\n-  [Master PDF Editor](https://code-industry.net/free-pdf-editor/#get)  (P.S. 居然是 QT 的静态编译)\n\n***\n\n\n\nDevelopment：\n\n- [Git](https://git-scm.com/)    `sudo apt-get install git` ；\n- [jdk](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) ；\n- [Nodejs](https://nodejs.org/) ；\n- [Golang](https://golang.org/) ；\n- codeblocks    [PPA 源](https://launchpad.net/~damien-moore/+archive/ubuntu/codeblocks-stable)安装:\n\n\n```\nsudo add-apt-repository ppa:damien-moore/codeblocks-stable\nsudo apt-get update\nsudo apt-get install codeblocks codeblocks-contrib\n```\n\n\n- [JetBrains](https://www.jetbrains.com/products.html) 系列：\n\n  - Clion\n  - idea-IU\n  - Webstorm\n- Android Studio\n- [Qt](http://download.qt.io/)\n- 系统环境变量设置：\n\n\n  修改`/etc/profile`文件为：\n\n  ```\n  # /etc/profile: system-wide .profile file for the Bourne shell (sh(1))\n  # and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).\n\n  if [ \"$PS1\" ]; then\n    if [ \"$BASH\" ] \u0026\u0026 [ \"$BASH\" != \"/bin/sh\" ]; then\n      # The file bash.bashrc already sets the default PS1.\n      # PS1='\\h:\\w\\$ '\n      if [ -f /etc/bash.bashrc ]; then\n        . /etc/bash.bashrc\n      fi\n    else\n      if [ \"`id -u`\" -eq 0 ]; then\n        PS1='# '\n      else\n        PS1='$ '\n      fi\n    fi\n  fi\n\n  if [ -d /etc/profile.d ]; then\n    for i in /etc/profile.d/*.sh; do\n      if [ -r $i ]; then\n        . $i\n      fi\n    done\n    unset i\n  fi\n\n  # Java Development Enviroment\n  export JAVA_HOME=/opt/jdk\n  export PATH=$JAVA_HOME/bin:$PATH\n  export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n\n  # Nodejs Development Enviroment\n  export NODE_HOME=/opt/node\n  export PATH=$PATH:$NODE_HOME/bin\n  export NODE_PATH=$NODE_HOME/lib/node_modules\n\n  # Android Development Enviroment\n  export ANDROID_HOME=/opt/android/sdk\n  export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools\n  export ANDROID_NDK_HOME=/opt/android/ndk\n  export PATH=$ANDROID_NDK_HOME:$PATH \n\n  #GO Development Enviroment\n  #GOPATH 是 Golang 的开发目录\n  #GOROOT 为 Golang 的安装目录\n  export GOPATH=\"/home/yang/projects/Go_workspace\"\n  export GOROOT=\"/opt/go\"\n  export PATH=$GOROOT/bin:$PATH\n  ```\n\n  ​\n\n***\n\n浏览器插件：\n\n- Chrome 插件：\n  - [Awesome Autocomplete for GitHub](https://chrome.google.com/webstore/detail/awesome-autocomplete-for/djkfdjpoelphhdclfjhnffmnlnoknfnd)\n  - [cVim](https://chrome.google.com/webstore/detail/cvim/ihlenndgcmojhcghmfjfneahoeklbjjh)\n  - [Intelli-Octo](https://chrome.google.com/webstore/detail/intelli-octo/hbkpjkfdheainjkkebeoofkpgddnnbpk)\n  - [IP Whois \u0026 Flags Chrome \u0026 Websites Rating](https://chrome.google.com/webstore/detail/ip-whois-flags-chrome-web/kmdfbacgombndnllogoijhnggalgmkon)\n  - [Local CDN](https://chrome.google.com/webstore/detail/local-cdn/dgfedofdiaapcideaajjaklpmdpcdapg)\n  - [Octotree](https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc)\n  - [Proxy SwitchyOmega](https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif)\n  - [Save to Pocket](https://chrome.google.com/webstore/detail/save-to-pocket/niloccemoadcdkdjlinkgdfekeahmflj)\n  - [Tampermonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo)\n  - [二管家:拓展管理，更新通知，自动管理拓展](https://chrome.google.com/webstore/detail/nooboss-extensions-manage/aajodjghehmlpahhboidcpfjcncmcklf)\n  - [优酷HTML5播放器](https://chrome.google.com/webstore/detail/youku-html5-player/fpnknfakcmgkbhccgpgnbaddggjligol)\n  - [广告终结者](https://chrome.google.com/webstore/detail/广告终结者/fpdnjdlbdmifoocedhkighhlbchbiikl)\n  - [Vue.js devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)\n\n\n\n- FireFox 插件：\n  - [Hide Caption Titlebar Plus](https://addons.mozilla.org/en-US/firefox/addon/hide-caption-titlebar-plus-sma/) (FireFox 57+ 暂不可用)\n  - [优酷HTML5播放器](https://addons.mozilla.org/zh-CN/firefox/addon/youku-html5-player/)\n  - [FoxyProxy Standard](https://addons.mozilla.org/zh-CN/firefox/addon/foxyproxy-standard/) (检测「科学上网」可用性前清除浏览器缓存)\n  - [Proxy SwitchyOmega](https://addons.mozilla.org/zh-CN/firefox/addon/switchyomega) \n  - [Octotree](https://addons.mozilla.org/zh-CN/firefox/addon/octotree/)\n  - [Tampermonkey](https://addons.mozilla.org/zh-CN/firefox/addon/tampermonkey/)\n  - [uBlock Origin](https://addons.mozilla.org/zh-CN/firefox/addon/ublock-origin/)\n\n**注**：Chrome 书签、Firefox 书签登陆自己账号，多平台同步。(当然，也可以浏览器设置，插件多平台同步)\n\n\n\n### 一些小技巧\n\n1.为鼠标右键添加新建 Word 文档，新建 Excel 文档，新建 Power Point 文档：\n\n把一个空白的文档放在“模板”文件夹(/home/\u003cyour-user-name\u003e/模板 或者 ~/模板，英文为 Templates 。如果没有此文件夹，则新建一个。)中，即刻生效，使用鼠标右键，马上就有了新建 Word 文档等这几个条目了。效果如图：\n\n![tips-office-templates](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/tips-office-templates.png)\n\n2.修复蓝牙蓝牙不可用问题（芯片组 BCM43142）\n   直接参考[这篇文章](https://memo.ink/fix-ubuntu-bluetooth-bcm/) 或者 [broadcom-bt-firmware](https://github.com/winterheart/broadcom-bt-firmware)。\n\n\n### 包搜索\n\n可从以下的网站搜索一些 .deb 和 .rpm 包：\n\n- https://pkgs.org\n- https://www.rpmfind.net\n- https://packages.ubuntu.com/search?keywords=search\n\n\n### 注意事项 \n\n不要轻易去动 menu 菜单编辑；\n不要轻易再安装或升级内核(因为动态内核模块 (DKMS) 等组件停留在原先的版本上，因此可能会产生不兼容的问题)。\n\n[Ubuntu 16.04 HWE内核安装Xtables-addons](https://www.kaijia.me/2017/05/ubuntu-16-04-hwe-kernel-install-xtables-addons/)\n\n\n\n### 补充\n\n这里补充的仅是一些比较感兴趣的软件，本人并未安装：\n\n- [Best Free and Open Source Alternatives to Adobe Products for Linux](https://itsfoss.com/adobe-alternatives-linux/)  \n  (Adobe 系列开源替代品)   \n\n\n\n### 总结\n\n目前，就这么多吧，随时间的推移会间断地修改一些。","cover":"","link":"./post/2017/06/20/my-linux-mint-configuration.html","preview":"\u003cp\u003e在使用自己的系统 (Linux Mint) 时，不由地担心万一哪天坏掉，要重装系统，这么多配置好的环境怎么恢复啊，因此整理出一篇博文记录一下自己平时常用软件以及开发环境配置，以备不时之需。\u003c/p\u003e\n","title":"我的 Linux Mint 『配置』清单"},{"content":"\n\n### PhantomJS\n\n首先，简单介绍一下 [PhantomJS](http://phantomjs.org/) ，它是一个基于 WebKit 的服务器端 JavaScript API ，无需浏览器的支持即可实现对 Web 的支持，且原生支持各种 Web 标准。适合使用在 _Web 测试_ ，当然也可以应对反爬虫。\n\n### 获取 Cookie\n\n有些网站的 cookie 很难用普通的爬虫获取，因为很多网站使用 ajax 动态加载网页内容，而且大多数时候 ajax 请求都会经过后台鉴权，这时就可以通过 **PhantomJS + Selenium** 模拟浏览器的行为，拿到经过 javascript 渲染后页面的内容。\n\n请看下面的这段代码，以 _[cnzz统计](http://www.umeng.com/)_ 为例：\n\n```python\n#!/usr/bin/python\n# coding:utf-8\nfrom selenium import webdriver\nfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilities\nimport time\n\nurl_login = 'https://i.umeng.com/loginframe?app_id=cnzz' \n# driver = webdriver.Remote(\n# command_executor='http://127.0.0.1:8080',\n# desired_capabilities=DesiredCapabilities.CHROME)\n# 这里为 phantomjs 的路径\ndriver = webdriver.PhantomJS(executable_path=\"/home/phantomjs/bin/phantomjs\")\ndriver.get(url_login)\n\n# cnzz 用户名\ndriver.find_element_by_xpath(\"//input[@data-reactid='.0.0.0.1.0.0.0.0.0.1']\").send_keys('\u003cyour cnzz email address\u003e') \n# cnzz 密码\ndriver.find_element_by_xpath(\"//input[@data-reactid='.0.0.0.1.0.0.1.0.0']\").send_keys('\u003cyour cnzz password\u003e') \n# 1 秒后再模拟点击登录按钮事件，这样更接近真实的用户交互\ntime.sleep(1)\ndriver.find_element_by_xpath(\"//input[@data-reactid='.0.0.0.1.2.0']\").click()  \n# 等待 5 秒后，再获取 cookie\ntime.sleep(5)\ncookie_list = driver.get_cookies()\n# print cookie_list\n\ncookie_str=''\nfor cookie in cookie_list:\n    # print (\"%s=%s;\" % (cookie['name'], cookie['value']))\n    cookie_str=cookie_str + cookie['name']+'='+cookie['value']+';'\n    driver.quit()\n    return cookie_str\n```\n\n\n\n#### 小实战\n\n有这样一个场景：\n\n假如我有一个网站(托管在 Github Pages 的静态网站)使用 cnzz 的网站访问统计，我需要一个这样的提醒服务：当有特定的 IP 访问我的网站时，要发邮箱提醒我。\n\n\n\n```python\n#!/usr/bin/python3\n# coding:utf-8\n\nimport requests\nimport time\nimport datetime\nimport pickle\n\n__author__ = 'zetaoyang'\n__version__ = '0.3.0'\n\n# 使用了 mailgun 的邮箱服务\ndef send_simple_message(visit_count,visit_time,listshow_ip):\n    return requests.post(\n\"https://api.mailgun.net/v3/sandboxfd8956dd22c742899928f5556dd679c7.mailgun.org/messages\",\n        auth=(\"api\", \"key-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"), # 此处填 mailgun 的 key\n        data={\"from\": \"Monitor Robot \u003cpostmaster@sandboxfd8956dd22c742899928f5556dd679c7.mailgun.org\u003e\",\n              \"to\": [\"xxxxx@xxx.xxx\"], # 此处填 收件人邮箱地址\n              \"subject\": \"Hello,xxx\",\n              \"html\": \"\u003chtml\u003e\u003cbody\u003eIP:2xx.1xx.2xx.0 ~ 2xx.1xx.2xx.255 has visited your website \"+str(visit_count)+\" times!\u003cbr\u003eMonitor time: \"+visit_time+\"\u003cbr\u003e\"+\"detail is :\"+ str(listshow_ip)+\"\u003c/body\u003e\u003c/html\u003e\"})\n\ndef FileCheck(fn):\n    try:\n        favorite_color = pickle.load(open(fn,\"rb\"))\n        return (1,favorite_color)\n    except IOError:\n        # print (\"Error: File does not appear to exist.\")\n        return (0,'error')\n\ndef get_cookie_from_network():\n    from selenium import webdriver\n    from selenium.webdriver.common.desired_capabilities import DesiredCapabilities\n    import time\n\n    url_login = 'https://i.umeng.com/loginframe?app_id=cnzz' \n    # driver = webdriver.Remote(\n    # command_executor='http://127.0.0.1:8080',\n    # desired_capabilities=DesiredCapabilities.CHROME)\n    driver = webdriver.PhantomJS(executable_path=\"/home/phantomjs/bin/phantomjs\")\n    driver.get(url_login)\n    \n    driver.find_element_by_xpath(\"//input[@data-reactid='.0.0.0.1.0.0.0.0.0.1']\").send_keys('\u003cyour cnzz email address\u003e') \n    driver.find_element_by_xpath(\"//input[@data-reactid='.0.0.0.1.0.0.1.0.0']\").send_keys('\u003cyour cnzz password\u003e') \n\n    time.sleep(1)\n    driver.find_element_by_xpath(\"//input[@data-reactid='.0.0.0.1.2.0']\").click()   \n    time.sleep(5)\n\n    cookie_list = driver.get_cookies()\n\n    cookie_str=''\n\n    for cookie in cookie_list:\n       # print (\"%s=%s;\" % (cookie['name'], cookie['value']))\n        cookie_str=cookie_str + cookie['name']+'='+cookie['value']+';'\n    # print (cookie_list)\n    driver.quit()\n    return cookie_str\n\n\ncurrent_unix_time = int(time.time()) + 28800 \n\nquery_date = datetime.datetime.fromtimestamp(current_unix_time).strftime('%Y-%m-%d') # '2017-03-08'\n\ndetail_time = datetime.datetime.fromtimestamp(current_unix_time).strftime('%Y-%m-%d %H:%M:%S') \n\nsite_id = 'xxxxxxxxxx' # your siteid\n\ncookie = get_cookie_from_network() \n\nurl = 'https://web.umeng.com/main.php?c=flow\u0026a=detail\u0026ajax=module%3DfluxData_option%3Dpv%7Cmodule%3DdetailPvList_currentPage%3D{current_page}_pageType%3D{page_size}\u0026siteid={site_id}\u0026st={start_date}\u0026et={end_date}\u0026visitorType=\u0026visitorAgent=\u0026visitorAct=\u0026location=\u0026refererType=\u0026ip=\u0026referer=\u0026keyword=\u0026hour=24\u0026page=\u0026cnzz_eid='\n\npv_logs = []\npage = 1\nhas_next = True\n\n# 保存上一次的查询结果到本地文件，防止重复发邮件\nif(FileCheck(\"/home/target_data.pkl\")[0] ==1):\n    target_num = FileCheck(\"/home/target_data.pkl\")[1]['num']\nelse:\n    pickle.dump({'num':'0000000000c1'},open(\"/home/target_data.pkl\",\"wb\"))\n    target_num = '0000000000c1'\n\nwhile has_next:\n    print (\"GET page %d \" % page)\n    response = requests.get(\n        url=url.format(current_page=page, page_size=90, start_date=query_date, end_date=query_date, site_id=site_id),\n        headers={\n            'Cookie': cookie,\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n            'Accept-Encoding': 'gzip, deflate, sdch, br',\n            #'X-Requested-With': 'XMLHttpRequest',\n        },\n    )\n\n    data = response.json()['data']['detailPvList']\n    pv_logs.extend(data['items'])\n    has_next = data['page']['hasNext'] == u'1'\n\n    page += 1\n\nprint ('Got %d pv logs' % len(pv_logs))\n\nip_visits = {}\nvisit_counts = {}\n\nfor pv in pv_logs:\n    ip_visits[pv['ip']] = ip_visits.get(pv['ip'], 0) + 1\n\nlist_ip = []\nfound_flag = False\ntotal_visits = 0\n\nfor ip, visits in sorted(ip_visits.items(), key=lambda ip: ip[1], reverse=True):\n    # 2xx.1xx.2xx.0~2xx.1xx.2xx.255 \n    ip_match=ip.split(\".\")\n    # print (len(ip_visits.items()))\n\n    if(ip_match[0]=='2xx' and ip_match[1]=='1xx' and int(ip_match[2]) \u003c= 2xx and int(ip_match[2]) \u003e= 2xx):\n        print ('here it is')\n        found_flag = True\n        list_ip.append(ip)\n        list_ip.append(visits)\n        total_visits += visits\n\n        query_unix_time = time.mktime(datetime.datetime.strptime(query_date, \"%Y-%m-%d\").timetuple())\n        favorite_number={\"num\":str(int(query_unix_time)) +'c'+ str(total_visits)}\n        # print (favorite_number['num'])\n        # if(target_num != favorite_number['num'] or found_flag==True):\n\n    \n    visit_counts[visits] = visit_counts.get(visits, 0) + 1\n\nprint (list_ip)\n\nif(found_flag==True):\n    if(target_num != favorite_number['num']):\n        pickle.dump(favorite_number,open(\"/home/target_data.pkl\",\"wb\"))\n        send_simple_message(total_visits,detail_time,list_ip)\n        print ('sended')\nelse:\n    print ('not found')\n```\n\n最后部署到服务器上，我部署到了 [IBM Bluemix](https://console.ng.bluemix.net/) 的 docker 容器(容器镜像是 [baseimage-docker](https://github.com/phusion/baseimage-docker) )上 ,crontab 定时任务`0 */3 * * * /usr/bin/python3 /home/cnzz_ip_count_and_email-v3.py`每3小时 访问一次 cnzz 获取数据。\n\n总结： 上面的方案不是最好的解决方案，因为实时性监测不好。我想到的另一种解决方案是 类似于 [IFTTT](https://ifttt.com/) ，网页前端 检测 特定IP 是否访问网站，然后触发访问一个发邮件接口(自己在 openshift 或 heroku 等平台搭建一个 接口服务)，这样似乎更好一些。最后感谢 [Brucezz](https://github.com/brucezz/) 和 [wuchangfeng](https://github.com/wuchangfeng) 提供的第一版脚本原型。\n\n### [补充]CasperJS\n\n[CasperJS](http://casperjs.org/) 是对 PhantomJS 更好的封装。\n\n再看一例，cnzz 统计设置了查看密码的情形：\n\n```javascript\nvar casper = require(\"casper\").create();\nvar x = require(\"casper\").selectXPath;  //用来简化XPath操作\n\ncasper.userAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36');\n\nvar siteid = '\u003cyour siteid\u003e' // cnzz 站点id,比如 1763173848\nvar url = 'http://new.cnzz.com/v1/login.php?siteid=1' + siteid;\ncasper.start(url, function(){\n    this.fill('form[name=\"form1\"]', {\n    'password': '\u003cyour cnzz view password \u003e'  // cnzz 的查看密码\n}, true);   //true, 填充完毕后,立刻提交表单\n});\n\ncasper.then(function(){\n    casper.wait(2000, function(){\n        this.capture('cnzz.png'); //截取整个页面\n    });\n});\n\ncasper.then(function(){\n    //this.captureSelector('cnzz.png', x('//*[@id=\"overview_top_order_table\"]')); //截取指定的selector\n});\n\ncasper.then(function(){\n    var today=this.evaluate(function(){\n        var tbl=document.getElementById(\"overview_top_order_table\");\n        return {\n            pv: tbl.rows[1].cells[1].innerHTML,\n            uv: tbl.rows[1].cells[2].innerHTML,\n            ip: tbl.rows[1].cells[3].innerHTML,\n        };\n    });\n    console.log(today.pv);\n    console.log(today.uv);\n    console.log(today.ip);\n});\ncasper.run();\n\n```\n\n\n\n### 参考资料\n\n[How to get the client IP address with Javascript only](http://ourcodeworld.com/articles/read/257/how-to-get-the-client-ip-address-with-javascript-only)  \n\n类似想法的服务还有：\n\n- [IFTTT](https://ifttt.com/) (if **this** then **that**)\n- [zapier](https://zapier.com/)\n\n3rd party ip service:\n\n- https://l2.io  \n- https://www.ipify.org  \n- https://myexternalip.com  \n- http://www.whatismypublicip.com  \n- https://ipinfo.io \n- https://ipinfo.io/developers  \n- https://ip.sb  \n- http://www.ipip.net   \n- https://www.maxmind.com/en/geoip2-services-and-databases  \n\n\n","cover":"","link":"./post/2017/04/28/phantomjs.html","preview":"\u003cp\u003e首先，简单介绍一下 PhantomJS ，它是一个基于 WebKit 的服务器端 JavaScript API ，无需浏览器的支持即可实现对 Web 的支持，且原生支持各种 Web 标准。适合使用在 \u003cem\u003eWeb 测试\u003c/em\u003e ，当然也可以应对反爬虫。\u003c/p\u003e\n","title":"初探 PhantomJS + Selenium 模拟浏览器行为"},{"content":"\n\n###  什么是 Geohash\n\nGeohash，是由 Gustavo Niemeyer  提出对地图坐标进行编码的一种方式。其思想策略是分治，将地理坐标值转化为二进制码。\n\n例如：坐标北京海淀区附近 L(116.308785,39.980778)，先对经度进行编码：\n\n首先，将区间 (-180.0,180.0) 分为 (-180.0,0.0)，(0.0,180.0)，如果经度属于前者，则二进制码为 0，否则为 1。因为 116.308785 属于 (0.0,180.0)，所以第一位为 1。  \n\n然后对 (0.0,180.0) 再进行一次二分，分为 (0.0,90.0),(90.0,180.0)，该经度属于后者，因此第二位仍然为 1。  \n\n第三次对 (90.0,180.0) 二分，第四次对 (90.0,135.0) 二分，这样经过多次分割之后(二分次数取决于经纬度的精度，这里经度的精度是 6 位小数)，就可以得到一个表示经度的二进制串：\n\n```\n1101001010110101010111100\n```\n\n同样地，对纬度 39.980778 也进行编码，可以得到表示纬度的二进制串：\n\n```\n1011100011011100100011101\n```\n\n最后一步，需要将两个经纬度编码进行合并，两个串「剪开」再「拼接」为一个二进制编码。\n\n依次取经度和纬度的每一位进行合并(奇数位为经度，偶数位为纬度)：\n```\nlon: 1 1 0 1 0 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 1 1 1 0 0\n\n     11100111010010001101101101110010011000101111110001\n     \nlat: 1 0 1 1 1 0 0 0 1 1 0 1 1 1 0 0 1 0 0 0 1 1 1 0 1\n```\n\n得到合并的二进制码后，需要将其每 5 位分为一组，并使用 base32 将其转化为对应的字符。介绍就这么多，如果还想详细地了解 Geohash ，就看本文最后的参考资料吧。\n\n### base32 编解码\n\n大家一定很好奇，为什么这里要提 base32 呢？因为我是用 C 实现嘛！(得自己造轮子)\n`base32.c`文件：  \n```C\n#include \u003cstdio.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cstdlib.h\u003e\n#include \"../include/base32.h\"\n\n//base32 表包含 0~9 以及小写字母 (去除'a','i','l','o')，\n//共 32 个字符\nstatic const char base32_alphabet[32] = {\n        '0', '1', '2', '3', '4', '5', '6', '7',\n        '8', '9', 'b', 'c', 'd', 'e', 'f', 'g',\n        'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r',\n        's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n};\n\n/**\n * 匹配 base32_alphabet\n * @param m char\n * @return i int\n */\nint find_number(char m) {\n    int i;\n    for(i = 0; i \u003c 32; ++i)\n    {\n        if(m == base32_alphabet[i])\n            return i;\n    }\n    return -1;\n}\n\n/**\n * base32 编码\n * @param bin_source char*\n * @return str char*\n */\n\nchar* base32_encode(char *bin_source){\n    int i;\n    int j = 0;\n    static char str[10];\n\n    for(i=0;i\u003cstrlen(bin_source);++i){\n        if((i+1)%5==0){\n            j++;\n            int num = (bin_source[i]-'0')+(bin_source[i-1]-'0')*2\\\n            +(bin_source[i-2]-'0')*2*2+(bin_source[i-3]-'0')*2*2*2\\\n            +(bin_source[i-4]-'0')*2*2*2*2;\n\n            str[j-1] = base32_alphabet[num];\n        }\n\n    }\n    return str;\n}\n\n/**\n * base32 解码\n * @param str_source char*\n * @return dec int*\n */\nint* base32_decode(char *str_source){\n    int i,j;\n    static int dec[50];\n    int count=0;\n    for(i=0;i\u003cstrlen(str_source);++i){\n        for(j=5-1;j\u003e=0;--j){\n            count++;\n            //位运算十进制转二进制\n            dec[count-1] = find_number(str_source[i])\u003e\u003e(j%5)\u00261;\n        }\n    }\n    return dec;\n}\n```\n\n### Geohash 实现\n\n```C\n#include \u003cstdio.h\u003e\n#include \"include/base32.h\"\n\n/**\n * 经纬度 二进制混合编码\n * @param lon double\n * @param lat double\n * @return char*\n */\nchar* encode(double lon, double lat){\n    double latM,lonM;\n    char lon_ans[25];\n    char lat_ans[25];\n    static char ans[50];\n    double lonL = -180.0, lonR = 180.0;\n    double latL = -90.0, latR = 90.0;\n    int i,j;\n    for(i=0;i\u003c25;++i){\n        latM = (latL + latR) / 2.0;\n        lonM = (lonL + lonR) / 2.0;\n        if(lon - lonM \u003e= 0) lon_ans[i] = '1', lonL = lonM;\n        else    lon_ans[i] = '0', lonR = lonM;\n        if(lat - latM \u003e= 0) lat_ans[i] = '1', latL = latM;\n        else    lat_ans[i] = '0', latR = latM;\n    }\n\n    //将两个经纬度进行合并，组合为一个二进制编码\n    for(j=0;j\u003c50;++j) {\n        if((j+1)%2==1) ans[j] = lon_ans[(j+1)/2];\n        else ans[j] = lat_ans[j/2];\n    }\n\n    return ans;\n}\n\n/**\n * 将二进制解码为经纬度\n * @param bin_num int*\n * @return double*\n */\ndouble* decode(int *bin_num){\n    int i;\n    double latM,lonM;\n    static double result[2];\n    double lonL = -180.0, lonR = 180.0;\n    double latL = -90.0, latR = 90.0;\n    int lon_ans[25];\n    int lat_ans[25];\n    for(i=0;i\u003c50;++i){\n        if((i+1)%2==1){\n            lon_ans[(i+1)/2] = bin_num[i];\n        }else{\n            lat_ans[(i/2)] = bin_num[i];\n        }\n    }\n\n    for(i=0;i\u003c25;++i){\n        if(lon_ans[i]==1){\n            lonL = lonM;\n            lonM = (lonL+lonR)/2.0;\n        }else if(lon_ans[i]==0){\n            lonR = lonM;\n            lonM = (lonL+lonR)/2.0;\n        }\n\n        if(lat_ans[i]==1){\n            latL = latM;\n            latM = (latL+latR)/2.0;\n        }else if(lat_ans[i]==0){\n            latR = latM;\n            latM = (latL+latR)/2.0;\n        }\n\n    }\n    result[0] = latM;\n    result[1] = lonM;\n    return result;\n}\n\nint main(){\n    int n,m;\n    double x,y;\n    double *lon_lat_res;\n    char *bin_str;\n    char *str;\n    char des_str[10];\n    int *bin_num;\n    int i,j;\n    scanf(\"%d %d\",\u0026n,\u0026m);\n\n//输入经纬度，输出 geohash 编码\n    for(i=0;i\u003cn;++i){\n        scanf(\"%lf %lf\",\u0026x,\u0026y);\n        bin_str = encode(x,y);\n        str = base32_encode(bin_str);\n        for(j=0;j\u003c10;++j){\n            printf(\"%c\",*(str+j));\n        }\n        printf(\"\\n\");\n    }\n\n//输入 geohash 编码，输出 经纬度\n    for(i=0;i\u003cm;++i){\n        scanf(\"%s\",des_str);\n        bin_num = base32_decode(des_str);\n        lon_lat_res = decode(bin_num);\n        //前面是经度，后面是纬度\n        printf(\"%lf %lf\\n\",*(lon_lat_res+1),*lon_lat_res);\n    }\n\n    return 0;\n}\n```\n\n输入：\n\n第 1 行：2 个整数 n,m。1≤n,m≤100。  \n第 2..n+1 行：每行 2 个实数 x,y，第 i+1 行表示第 i 个点的纬度和经度。-90≤x≤90，-180≤y≤180  \n第 n+2..n+m+1 行：每行 1 个字符串，表示需要解码的 Geohash 串。  \n\n输出：\n\n第 1..n 行：每行 1 个字符串，第 i 行表示以第 i 个点的 Geohash 编码，长度为 10。  \n第 n+1..n+m 行：每行 2 个实数 x,y。  \n第 n+i 行表示以第 i 个 geohash 编码所表示的区域中心点坐标，保留 6 位小数。  \n\n运行结果：\n```\n\u003e\u003e\u003e ./geohash.exe\n\u003e\u003e\u003e 3 2\n\u003e\u003e\u003e 117.103367 36.255833\nww7q2b0jd1\n\u003e\u003e\u003e 112.688922 27.293056\nwsb5k299d4\n\u003e\u003e\u003e 110.082600 34.477861\nwqnk0ux8n7 \n\u003e\u003e\u003e wx0csn0ng8\n113.730624 39.672792 \n\u003e\u003e\u003e ww0k7k0et7\n112.995302 34.519663\n```\n\n完整 Clion 工程[在这](https://github.com/ZetaoYang/Code/tree/hihocoder)(包含 .exe 可执行文件)。\n\n### 代码解释\n\n我认为算法实现的核心就是「二分」，这部分没什么可讲的。在实现过程中最令我头疼是十进制转二进制(不要告诉我用 itoa()，sprintf()，因为 itoa() 在 Linux 中没有此函数 )，需要将十进制数转为 5 位的二进制数，这里用位运算更方便一些。例如：x 为需要转化的十进制数，  \n```C\nfor(i=5-1;i\u003e=0;--i) printf(\"%d\",x\u003e\u003ei\u00261);\n```\n\n我们都知道，奇数的二进制最后一位全部为`1`，而偶数的二进制最后一位全部为`0`，这样用按位与运算可以很方便地知道一个数是奇数还是偶数，只要让数字`\u00261`就可以了，因为`奇数 \u0026 1=1`，而`偶数 \u0026 1=0`。`x\u003e\u003ei`—— x 右移 i 位，相当于被 2 除了 i 遍。\n\n这段代码被用在 bas32.c 的 base32_decode() 函数。\n\n### 参考资料\n\n* [Geohash,Wikipedia](https://en.wikipedia.org/wiki/Geohash)\n* [GeoHash 核心原理解析](http://www.cnblogs.com/LBSer/p/3310455.html)\n* [Geohash 算法的 8 个矩形](http://evthoriz.com/2015/07/02/Geohash%20%E7%AE%97%E6%B3%95%E7%9A%84%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98/)\n* [geohash：用字符串实现附近地点搜索](http://charlee.li/geohash-intro.html)\n* [Python module Geohash](https://github.com/vinsci/geohash/)","cover":"","link":"./post/2017/03/20/geohash.html","preview":"\u003cp\u003eGeohash，是由 Gustavo Niemeyer  提出对地图坐标进行编码的一种方式。其思想策略是分治，将地理坐标值转化为二进制码。\u003c/p\u003e\n","title":"Geohash 编码解码 C 语言实现"},{"content":"\n\n现在很多 APP 都有夜间模式，看到简书网站改版后也添加了夜间模式切换，所以就在自己的博客上实践。至于 Service Worker 是什么本文不再赘述，只是将实现过程记录下来，供各位看官参考。\n\n### 如何实现夜间模式\n\n其实，实现网页夜间模式的样式大致有两种方式：一种是直接在页面最上层添加一个半透明黑色遮罩，具体可参考『[使用 javascript 为网页增加夜间模式](http://www.jb51.net/article/46223.htm) 』另一种就是修改背景样式。网上有很多修改 CSS 样式太复杂，这里提供一个简单的示例：\n\n```\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead \u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003ctitle\u003enight-mode\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody style=\"background-color: rgb(255, 255, 255)\"\u003e\n    \u003cp\u003eswitch button below!\u003c/p\u003e\n    \u003ch1\u003eHere\u003c/h1\u003e\n    \u003cbutton onclick=\"darker()\"\u003eSwitch\u003c/button\u003e\n    \u003cscript type=\"text/javascript\"\u003e\n    function darker() {\n        if (document.body.style.backgroundColor == 'rgb(255, 255, 255)') {\n\n                document.body.style.backgroundColor = 'rgb(6, 23, 37)';\n        }\n        else {\n                document.body.style.backgroundColor = 'rgb(255, 255, 255)';\n        }\n    }\n    \u003c/script\u003e\n    \n\u003c/body\u003e\n\u003c/html\u003e\n```\n将上面的代码拷贝下来，保存到 HTML 文件中，看看效果。\n\n\n### 客户端存储数据\n\n仅仅按上面那样做是不够的，因为当你刷新标签页后，一切效果皆都消失，所以客户端(在这里也就是浏览器)还需要存储转换状态。\n\nHTML5 提供了两种在客户端存储数据的方法：\nlocalStorage —— 没有时间限制的数据存储，需手动清除\nsessionStorage—— 针对 session 的数据存储，标签页关闭或者浏览器关闭后自动清除  \n(以上两种方法最大能存储 5MB 数据)\n其他具体相关细节可查阅 [MDN](https://developer.mozilla.org/)。\n\n然后就只是修改上面的 Javascript 代码：\n```\ndocument.body.style.backgroundColor = sessionStorage.getItem('bg');\ndocument.body.style.color = sessionStorage.getItem('md');\n\nfunction darker() {\n         if ( sessionStorage.getItem('bg') === 'rgb(255, 255, 255)') {\n\t\tsessionStorage.setItem('bg', 'rgb(6, 23, 37)');\n        sessionStorage.setItem('md', 'night');\n     }\n    \telse if (sessionStorage.getItem('bg') == null || undefined) {\n        sessionStorage.setItem('bg', 'rgb(6, 23, 37)');\n        sessionStorage.setItem('md', 'night');  \n    }\n    \telse if( sessionStorage.getItem('bg') === 'rgb(6, 23, 37)') {\n        sessionStorage.setItem('bg', 'rgb(255, 255, 255)');\n        sessionStorage.setItem('md', 'day');\n    }\n\ndocument.body.style.backgroundColor = sessionStorage.getItem('bg');\ndocument.body.style.color = sessionStorage.getItem('md');\n\n}\n```\n\n\n\n另外还可以更精细地修改自己博客的 CSS 样式。[demo](https://zetaoyang.github.io/) 就是我的独立博客，奥秘就在左边的那个刷子。\n\n\n\n### Service Worker 加速网页\n\n首先，引入 `serviceworker.js`\n\n```\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('/serviceworker.js')\n    .then(function(registration) {\n    //Register succeed.\n    console.log('[Service Worker] Registered，rage is', registration.scope);\n    }).catch(function(err) {\n    //Register failed.\n      console.log('[Service Worker] Register failed:', err);\n    });\n}\n```\n\n`serviceworker.js ` 文件的内容(我的博客直接将 `serviceworker.js` 放得到了根目录，作用全局)，链接在此： https://zetaoyang.github.io/serviceworker.js 。\n\n![serviceworker](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/blog-serviceworker.png)  \n注：serviceworker 生产环境只能是`https`,本地测试环境可以是`http://localhost`。\n\n### CDN 加速网页\n\n利用 CDN 服务 来加速你的网络。\n#### 国内：\n\n[BootCDN](http://www.bootcdn.cn/)  \n[又拍云 JS 库加速服务](http://jscdn.upai.com/)  \n[开放静态文件 CDN](https://staticfile.org/)  \n[百度静态资源公共库](http://cdn.code.baidu.com/)  \n\n#### 国外：\n\n[Google Hosted Libraries](https://developers.google.com/speed/libraries/)  \n[cdnjs](https://cdnjs.com/)   \n[jsDelivr](https://www.jsdelivr.com/) (有[国内节点](https://www.jsdelivr.com/features/cdn-in-asia-and-china))  \n\n注：\n万一 CDN 服务挂了，还可以从自己的服务器上读取：\n```\n\u003cscript src=\"//cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"\u003e\u003c/script\u003e\n\u003cscript\u003ewindow.jQuery || document.write('\u003cscript src=\"/jquery.min.js\"\u003e\u003c\\/script\u003e')\u003c/script\u003e\n```\n可参考 [Stack Overflow](http://stackoverflow.com/questions/5257923/how-to-load-local-script-files-as-fallback-in-cases-where-cdn-are-blocked-unavai) 。\n\n### 相关资料\n\n[【翻译】Service Worker 入门](https://w3ctech.com/topic/866)  \n[Service Workers 初体验](https://www.w3ctrain.com/2016/09/17/service-workers-note/)  \n谷歌搜索的 serviceworker 文件：https://www.google.com/_/chrome/newtab-serviceworker.js  \n[HTML5-Service Worker 实现离线页面访问](http://blog.csdn.net/qiqingjin/article/details/51629278)","cover":"","link":"./post/2017/02/27/add-night-mode-and-service-worker-for-your-blog.html","preview":"\u003cp\u003e现在很多 APP 都有夜间模式，看到简书网站改版后也添加了夜间模式切换，所以就在自己的博客上实践。至于 Service Worker 是什么本文不再赘述，只是将实现过程记录下来，供各位看官参考。\u003c/p\u003e\n","title":"给你的独立博客加上夜间模式以及 Service Worker"},{"content":"\n\n2016 年即将结束，马上迎来 2017。我在 Github 上的独立博客将近有半年了。最初博客由 Hexo 驱动，后来迁移到了 Hugo 阵营，再后来用上了「紙小墨」。总之，就是不断地在折腾。「学而不思则罔，思而不学则殆」。编程与写博客并不冲突，编程是一个学习与探究的过程，而写博客则是一个分享与梳理知识的过程。\n\n\n\n2016年，我是在学 \n\n- Nodejs ，以及 利用 Electron 制作跨平台的桌面应用。\n- Linux 下使用 AppImage 打包分发应用。\n- Love2d 引擎写了简单的游戏。\n- 后来又学习了 Vue \n- 最后打算用 React Native 写一个天气的 Android App。\n- 另一方面，我加入了 [众成翻译](http://zcfy.cc)  以及 [掘金翻译计划](https://github.com/xitu/gold-miner)，以提高英文水平，多看看国外大牛的优秀文章。\n- ......\n\n\n\n十月份给博客加上了访客统计。\n\n## 博客统计报告(过去 90 天)\n\n目前是直接使用  Google Analytics 统计代码(接下来会参考 [JerryQu](https://imququ.com) 大神的，然后自己实现 JavaScript 统计代码 + 服务端转发的方式使用 Google Analytics。)\n\n过去的 90 天里，本博客的访问情况基本如下图： \n![基本访问情况](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/2016-90-days-summary.png)  \n\n在这期间，我加入了 [Itscoder](https://www.itscoder.com) 这个组织，每期交作业，都可以蹭到组织的流量。所以每到组织发布文章的时候，访问量都很高。另外在众成翻译 ，有时间就去挑几篇感兴趣的国外技术博客翻译。\n\n**地理位置与语言**\n\n显然，本博客主要流量都来自于中国大陆，占到 45.81%。这里的俄罗斯流量中有一些是不正常的流量，所以中国大陆的占比应该比 45.81% 更高一些。\n\n![地理位置情况](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/2016-90-days-summary-geography.png) \n\n\n\n**操作系统与浏览器**\n\n来自 Windows 的流量占到了 38.07%，Mac OS 占到了 33.19%，其余份额被 IOS ，Linux ，Android ，Windows Phone 瓜分。\n\n![操作系统情况](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/2016-90-days-summary-os.png)  \n\n浏览器方面，来自 Chrome 已经占到了 72.22%。这里 “ɢoogle.com” 就是那个不正常的流量(你能分出 “Google.com” 和 “ɢoogle.com” 的区别吗？),它是一个假冒网站骗取流量的。\n\n![浏览器情况](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/2016-90-days-summary-brower.png)\n\n**流量来源**\n\n本博客流量来源主要是第三方网站引荐、搜索引擎、直接访问这三方面。 如下：\n\n![流量来源](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/2016-90-days-summary-channel.png)  \n\n\n\n本博客的具体来源：\n\n\n![具体来源](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/2016-90-days-summary-source.png)  \n\n\n\n2016 已经成为记忆，展望 2017：\n\n2017 我相信我的生活会有更多的改变，最后\n\n_望你我，不忘初心，继续成长，继续前行_ 。\n","cover":"","link":"./post/2016/12/30/2016-summary.html","preview":"\u003cp\u003e2016 年即将结束，马上迎来 2017。我在 Github 上的独立博客将近有半年了。最初博客由 Hexo 驱动，后来迁移到了 Hugo 阵营，再后来用上了「紙小墨」，总之，就是不断地折腾。十月份给博客加上了访客统计。\u003c/p\u003e\n","title":" 2016 年，我的收获与成长 "},{"content":"\n\n\u003e 本文是在众成翻译认领翻译的，原文链接在这 [here](https://blog.repick.co/the-best-inspiration-sites-for-inspiration-f28e86be6f7e#.sxv8xqm5u)  。感谢[月影](https://www.h5jun.com/post/the-best-inspiration-sites-for-inspiration.html)审校润色。\n\n\n\n![](http://p0.qhimg.com/t01de27041579151653.png)\n\n### [Repick](https://repick.co/?ref=blog.repick.co)\n\n从网上采集设计出众的产品，几乎每天更新。大部分展品来自亚马逊，也有一部分来源于其他网站。由专家团负责甄选以保持同样的产品风格。\n\n[![](http://p0.qhimg.com/t01e1c3a741dd1cb997.png)](https://repick.co/?ref=blog.repick.co)\n\n\n\n### [Dribbble](http://dribbble.com)\n\nDribbble 诞生于 Salem, MA（塞勒姆，马萨诸塞州），如今它已经成为设计师们分享作品，相互交流，获取灵感的平台。这是所有 App 和 Web 设计师的必备网站。\n\n![](http://p0.qhimg.com/t01033012e6d320023b.png)\n\n\n\n### [Muzli](https://muz.li/)\n\n Muzli 是一个采集和陈列各种设计灵感和新闻的工具。它是一个 Chrome 插件，在新标签页中展现推荐内容。Muzli 的内容来自许多不同的采集源，范围从如 Dribbble 这类纯粹设计灵感的平台到 ProductHunt 这类更多面向科技和创业公司的网站。\n\n![](http://p0.qhimg.com/t016a9f54e4cdabcea5.png)\n\n\n\n### [Lapa](http://lapa.ninja/)\n\nLapa 是分门别类展示各种网站着陆页的平台。他们的收藏是绝对惊人的，是所有对设计感兴趣的人的必备网站。\n\n![](http://p0.qhimg.com/t01b73066b5b866e050.png)\n\n\n\n### [Little Big Details](http://littlebigdetails.com/)\n\nLittle Big Details 是一个博客，带领读者发现小的、常被忽视的设计元素，这些元素给用户带来非常棒的数字体验。它真正地关注细节。\n\n![](http://p0.qhimg.com/t013529d3143e682948.png)\n\n\n\n### [Land Book](http://land-book.com)\n\nLandbook 收集了大量产品着陆页。它和 Lapa 一样有非常大量的收藏。如果你是第一次访问这个网站，一定要仔细看看。\n\n![](http://p0.qhimg.com/t0130b713af811abb82.png)\n\n\n\n### [UI Movement](https://uimovement.com)\n\nUI Movement 收集了不计其数的 gif 图像，能带给你 web 与 mobile 动画相关的灵感。这里能找到一些非常好的动画。\n\n![](http://p0.qhimg.com/t015ed8bf6004f47391.png)\n\n[![](http://p0.qhimg.com/t015119baaa36736b6a.png)](https://repick.co/?ref=blog.repick.co)\n\n\n\n### [Product Pages](http://productpages.xyz)\n\n专门收集产品的网站，列出最好的产品首页、价格页和库存页。顺便提一下，前面推荐的 Repick 也在这个网站里列出。\n\n![](http://p0.qhimg.com/t0126793d498d656962.png)\n\n\n\n### [Behance](http://www.behance.com)\n\nBehance 是个非常棒的地方，能够编排和展示你的设计作品集，并从其他设计师那里获得灵感。\n\n![](http://p0.qhimg.com/t0138dcfcefd06c8b3f.png)\n\n\n\n### [Mobile Patterns](http://www.mobile-patterns.com)\n\nMobile Patterns 分类展示流行的应用程序如何处理各种 UX 流和元素。\n![](http://p0.qhimg.com/t01a6c3477cb3d39527.png)\n\n\n\n### [Uplabs](http://www.uplabs.com)\n\nUplabs 是一个社区，设计师们在上面分享和出售他们的作品。\n\n![](http://p0.qhimg.com/t0189b0feccebc6ae8c.png)\n\n\n\n以上就是今天推荐的所有内容了，如果你发现了新的东西，或者你觉得我们错过了一些非常出色的东西，请在下方评论区里让我们知道。我希望你有所得，希望你的所得能激励你成为一名更好的设计师。\n\n![](http://p0.qhimg.com/t01b4ab87c5a1647349.png)\n\n[![](http://p0.qhimg.com/t01d601822bba87f47e.png)](https://repick.co/?ref=blog.repick.co)","cover":"","link":"./post/2016/12/24/t-top-inspiration-websites-for-designers.html","preview":"\u003cp\u003e本文是在众成翻译认领翻译的，原文链接在这 here。感谢月影审校润色。\u003c/p\u003e\n","title":"[译] 给予设计师灵感的 11 个顶尖网站"},{"content":"\n\n由于 Windows 系统没有提供本地环回网络的接口，所以用 [Wireshark](https://www.wireshark.org) 只能看到经过网卡的数据流量，看不到访问 localhost/127.0.0.1 的流量。\n现有四种解决方案：  \n\n一、 操作本机网络路由表(不推荐)  \n\n1. 以管理员权限运行终端(或 cmd)；\n2. `route add 本机ip mask 255.255.255.255 网关ip`\n\neg.  `route add 172.29.163.161 mask 255.255.255.255 172.29.163.1`\n\n注：使用完后再用`route delete 172.29.163.161 mask 255.255.255.255 172.29.163.1`删除这条记录，否则的话所有本机的报文都要经过网卡。  \n\n**背后的原理**：这样做是将发往本机的包发到网关，此时 Wireshark 就可以捕获到网卡驱动的报文。但是，如果本地请求的 URL 的 ip 只能写成本地的 ip 地址，不能写成 localhost 或 127.0.0.1，否则还是抓不到环回包。\n\n\n\n二、添加 Microsoft Loopback Adapter(不推荐)  \n\n之所以我不推荐的原因是，因为我也没折腾过。\n\n\n\n三、使用 RawCap   \n\n需要管理员权限运行 [RawCap](http://www.netresec.com/?page=RawCap)  。\n\n进入终端(cmd),然后运行：  \n\n```\nRawCap.exe 127.0.0.1 dumpfile.pcap \n或\nRawCap.exe 本地IP dumpfile.pcap\n```\n\n抓好包后，按 `Ctrl+C`，停止抓包。此时会在 RawCap 的同级目录下生成一个`dumpfile.pcap`文件。用 Wireshark 打开，就可以看到本地环回的数据包了。  \n\n\n\n四、使用 Npcap\n\n [Npcap](https://github.com/nmap/npcap/releases) 是对当前最流行的 WinPcap 工具包进行改进的一个项目。\n\n**安装前请先卸载 WinPcap**(可以在Wireshark 的`Help`一栏查看是否在使用 Npcap)  。\n\n安装时要勾选\n\n`Use DLT_NULL protocol sa Loopback ... `和 \n\n`install npcap in winpcap api-compat mode`(选这个，是要兼容 WinPcap)\n\n![npcap-0.78-r2](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/npcap-0.78-r2.png)\n\n\n\n安装完成启动 Wireshark, 可以看到在网络接口列表中，多了一项 `Npcap Loopback adapter`，这个就是来抓本地环回包的网络接口。\n\n![wireshark-npcap 捕获界面](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/wireshark-npcap.png)\n\n\n\n**参考资料**\n\n[替代 WinPcap 的新型 Windows 网络数据包截获软件——NPcap](http://blog.csdn.net/hsluoyc/article/details/46483151)\n\n[CaptureSetup/Loopback](https://wiki.wireshark.org/CaptureSetup/Loopback)\n\n","cover":"","link":"./post/2016/12/04/wireshark-npcap.html","preview":"\u003cp\u003e由于 Windows 系统没有提供本地环回网络的接口，所以用 Wireshark 只能看到经过网卡的数据流量，看不到访问 localhost/127.0.0.1 的流量。\u003c/p\u003e\n","title":"Wireshark 监听 localhost/127.0.0.1 环回地址的方法"},{"content":"\n昨天在自己的 VPS (运行 Debian8 64bits)上，使用 [Caddy](https://caddyserver.com/)  作为 Web 服务器。现将配置流程记录一下。  \n\n### 安装 Caddy  \n\nCaddy ——『 The HTTP/2 web server with automatic HTTPS 』，使用 GO 编写。  \n\n![caddy-server](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/caddy-server.png)  \n在本地下载 Caddy ，目录大致如下：  \n```\n.\n|-- caddy\n|-- init\n|   |-- README.md\n|   |-- freebsd\n|   |   `-- caddy\n|   |-- linux-systemd\n|   |   |-- README.md\n|   |   `-- caddy.service\n|   |-- linux-sysvinit\n|   |   |-- README.md\n|   |   `-- caddy\n|   `-- linux-upstart\n|       |-- README.md\n|       `-- caddy.conf\n```\n然后用`scp`命令或者用 [WinScp](https://winscp.net) (一个利用 `SFTP` 协议并且基于 `Putty`的 Windows 上的图形化软件)来上传。  \n给 `caddy` 赋予可执行权限后，再复制到`/usr/local/bin`：     \n\n```\nchmod +x caddy \nmv caddy /usr/local/bin/\n```\n### 配置 Caddy  \n\nCaddy 的配置文件为`Caddyfile`(在此之前需要配置好网站`example.com`(你的域名)的权威 DNS 的 A 记录或者 AAAA 记录)：  \n```\nexample.com {\n  gzip\n  root /var/www/html/\n}\n```\n配置完成后，运行：\n```\n/usr/local/bin/caddy --conf=/etc/caddy/Caddyfile\n```\n这样 Web 服务器就运行其来了。接下来后介绍配置`Systemd`运行 Caddy。     \n如果没有注册过 SSL 证书，此时会要你输入的邮箱下载[ Let’s encrypt](https://letsencrypt.org) 的证书了，此时要保证域名的 DNS 已经配置好了。\n\n### 配置 Systemd  \n\n使用`Systemd`注册`caddy`为一个服务，开机自动运行。\n如上文我们所看到的那样，`caddy`的下载压缩文件中包含一个`init`文件夹，其中包含`systemd`，`upstart`，`sysvinit`等各种的启动脚本。  \n\n`Systemd` 配置文件`caddy.service`：  \n```\n[Unit]\nDescription=Caddy HTTP/2 web server\nAfter=syslog.target\nAfter=network.target\n\n[Service]\nUser=root\nGroup=root\nLimitNOFILE=64000\nExecStart=/usr/local/bin/caddy --conf=/path/to/Caddyfile\nRestart=on-failure\n\n[Install]\nWantedBy=multi-user.target\n```\n配置文件写好后，运行：  \n```shell\ncd init/linux-systemd/\ncp caddy.service /etc/systemd/system/\nsystemctl start caddy  #启动\n```\n\n还可查看启动状态：\n```shell\nsystemctl status caddy #查看启动状态\n```\n\n### 如何安装插件  \n\n对于如何安装插件，可参考  \n[无闻的博客](https://wuwen.org/2015/11/13/caddy-in-action.html)    \n[Caddy Doc](https://caddyserver.com/docs/faq)  ","cover":"","link":"./post/2016/11/13/caddy-server.html","preview":"\u003cp\u003e昨天在自己的 VPS (运行 Debian 8 64bits )上，使用  Caddy 作为 Web 服务器。现将配置流程记录一下。\u003c/p\u003e\n","title":" Debian 上搭建 Caddy Server "},{"content":"\n\n尝试了一下，Windows 下 Codeblocks 利用 Mingw 编译器编写动态链接库，结果虽然 dll 是生成了，但过程还是不太满意。因为 dll 是 Windows 下才用到的，似乎用 GNU 的编译器不太合适，最终还是改用 VS2015 (虽然它很‘臃肿’)。然后，我就尝试在 Linux 上编写`.so`(shared object, 共享库。和 dll 类似)文件。    \n在 Linux 上，我尝试了 JetBrains 家的 Clion ，它的代码提示，确实比 Codeblock 好，这点值得肯定。而且在 Linux 上的构建速度比在 Windows 上快(相同硬件条件下) 。虽然 Clion 是收费软件，但是有学生优惠。我用 edu 邮箱申请一年期的免费使用权，到期之后还可以用 edu 邮箱再次验证使用。在能力范围之内，能不用破解软件，就不用破解软件。要**尊重同行的劳动**。 \n\n回到正题，静态库、动态库在不同系统下的对应关系：  \nlinux： `.a` (Archive libraries) 和 `.so`(Shared object)  ;     \nWindows： `.lib` 和 `.dll`(Dynamic-link library)\n\n### 先编写一个库试试  \n首先用 Clion 新建一个项目 \"hello\"，main.cpp 的内容为：  \n\n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\nvoid hi()\n{\n    cout \u003c\u003c \"Hello,nihao\" \u003c\u003c endl;\n}\nint add(int a,int b)\n{\n    return a + b;\n}\n```\n\nCMakeLists.txt (学名：组态档)的内容：  \n```\ncmake_minimum_required(VERSION 3.6)\nproject(hello)\n\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n\nset(SOURCE_FILES main.cpp)\n#动态库\nadd_library(hello SHARED ${SOURCE_FILES})\n#静态库\nadd_library(hell ${SOURCE_FILES})\n```\n编译生成`libhello.so`。 可用`nm -C libhello.so`来查看符号表：  \n```\n0000000000201040 B __bss_start\n0000000000201040 b completed.7585\n                 U __cxa_atexit@@GLIBC_2.2.5\n                 w __cxa_finalize@@GLIBC_2.2.5\n0000000000000840 t deregister_tm_clones\n00000000000008d0 t __do_global_dtors_aux\n0000000000200dd0 t __do_global_dtors_aux_fini_array_entry\n0000000000201038 d __dso_handle\n0000000000200de0 d _DYNAMIC\n0000000000201040 D _edata\n0000000000201048 B _end\n00000000000009e4 T _fini\n0000000000000910 t frame_dummy\n0000000000200dc0 t __frame_dummy_init_array_entry\n0000000000000af0 r __FRAME_END__\n0000000000201000 d _GLOBAL_OFFSET_TABLE_\n00000000000009cf t _GLOBAL__sub_I_main.cpp\n                 w __gmon_start__\n00000000000009fc r __GNU_EH_FRAME_HDR\n00000000000007b8 T _init\n                 w _ITM_deregisterTMCloneTable\n                 w _ITM_registerTMCloneTable\n0000000000200dd8 d __JCR_END__\n0000000000200dd8 d __JCR_LIST__\n                 w _Jv_RegisterClasses\n0000000000000880 t register_tm_clones\n0000000000201040 d __TMC_END__\n0000000000000940 T hi()\n0000000000000972 T add(int, int)\n0000000000000986 t __static_initialization_and_destruction_0(int, int)\n                 U std::ostream::operator\u003c\u003c(std::ostream\u0026 (*)(std::ostream\u0026))@@GLIBCXX_3.4\n                 U std::ios_base::Init::Init()@@GLIBCXX_3.4\n                 U std::ios_base::Init::~Init()@@GLIBCXX_3.4\n                 U std::cout@@GLIBCXX_3.4\n                 U std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026 std::endl\u003cchar, std::char_traits\u003cchar\u003e \u003e(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026)@@GLIBCXX_3.4\n00000000000009ed r std::piecewise_construct\n0000000000201041 b std::__ioinit\n                 U std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026 std::operator\u003c\u003c \u003cstd::char_traits\u003cchar\u003e \u003e(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026, char const*)@@GLIBCXX_3.4\n```\n\n\n### 动态库显式调用(运行时装入)  \n新建一个项目 \"openso\"，以下是`main.cpp`的内容：  \n```c++\n#include \u003ciostream\u003e\n#include \"dlfcn.h\"//显式调用的头文件\n\nusing namespace std;\n\nint main() {\n\n    cout \u003c\u003c \"C++ dlopen\" \u003c\u003c endl;\n\n    // 打开库文件\n    cout \u003c\u003c \"Opening libhello.so...\" \u003c\u003c endl;\n    //动态库 libhello.so 的绝对路径\n    void *handle = dlopen(\"/home/yang/Desktop/openso/lib/libhello.so\", RTLD_LAZY);\n\n    if (!handle) {\n        cerr \u003c\u003c \"Cannot open library: \" \u003c\u003c dlerror() \u003c\u003c endl;\n        return 1;\n    }\n\n    // 加载符号表\n    cout \u003c\u003c \"Loading symbol hi...\" \u003c\u003c endl;\n    typedef void (*hi_t)();\n\n    // 错误\n    dlerror();\n    hi_t hi = (hi_t) dlsym(handle, \"hi\");\n    const char *dlsym_error = dlerror();\n    if (dlsym_error) {\n        cerr \u003c\u003c \"Cannot load symbol 'hi': \" \u003c\u003c dlsym_error \u003c\u003c endl;\n        dlclose(handle);\n        return 1;\n    }\n\n    cout \u003c\u003c \"Calling hi()...\" \u003c\u003c endl;\n    hi();\n\n    // 加载符号表\n    cout \u003c\u003c \"Loading symbol add...\" \u003c\u003c endl;\n    typedef int (*add_t)(int, int);\n\n    // 错误\n    dlerror();\n    add_t add = (add_t) dlsym(handle, \"add\");\n    if (dlsym_error) {\n        cerr \u003c\u003c \"Cannot load symbol 'add': \" \u003c\u003c dlsym_error \u003c\u003c endl;\n\n        dlclose(handle);\n        return 1;\n    }\n\n    cout \u003c\u003c \"Calling the add()...\"\u003c\u003c endl;\n    cout \u003c\u003c add(2, 3) \u003c\u003c \" is the result\"\u003c\u003c endl;\n\n    // 关闭库文件\n    cout \u003c\u003c \"Closing library...\"\u003c\u003c endl;\n    dlclose(handle);\n}\n```\n\nCMakeLists.txt 的内容： \n```\ncmake_minimum_required(VERSION 3.6)\nproject(openso)\n\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\nset(SOURCE_FILES main.cpp)\nadd_executable(openso ${SOURCE_FILES})\ntarget_link_libraries(openso ${CMAKE_DL_LIBS})\n```\n编译，也可以在项目的根目录下执行`g++ -o main main.cpp -ldl`。\n\n程序运行结果如下：  \n\n```\nC++ dlopen\nOpening libhello.so...\nLoading symbol hi...\nCalling hi()...\nHello,nihao\nLoading symbol add...\nCalling the add()...\n5 is the result\nClosing library...\n```\n\n\n\n### 动态库隐式调用(编译时装入)  \n新建一个项目 \"hideso\"，以下是`main.cpp`的内容：  \n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\nvoid hi();\nint  add(int,int);\n\nint main(int argc,char *argv[])\n{\n    hi();\n    cout \u003c\u003c endl;\n    cout \u003c\u003c add(13,12) \u003c\u003c endl;\n    return 0;\n}  \n```\n\nCMakeLists.txt 的内容：  \n```   \ncmake_minimum_required(VERSION 3.6)\nproject(hideso)\n\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n\nset(SOURCE_FILES main.cpp)\nadd_executable(hideso ${SOURCE_FILES})\ntarget_link_libraries(hideso /home/yang/Desktop/hideso/libhello.so)\n```\n编译，也可以在项目的根目录下执行` g++ -o main main.cpp ./libhello.so`。\n\n在执行隐式链接的程序之前，需要设置 LD_LIBRARY_PATH 环境变量，或者把前面生成的 libhello.so 复制到系统路径下，否则报错：  \n```\nerror while loading shared libraries: libhello.so: cannot open shared object file: No such file or directory\n```\n运行可在项目根目录下执行：  \n```\nexport LD_LIBRARY_PATH=.\n./main\n```\n还可直接用`ldd`命令查看其所隐式调用的库。  \n\n\n对于 C 语言编译的库，C++ 调用时需要这么做(保证C/C++ 兼容性，注意`cplusplus`前面是两个'_')：    \n\n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\tvoid hi();\n\tint add(int,int);\n#ifdef __cplusplus\n}\n#endif\n\nint main(int argc,char *argv[])\n{\n    hi();\n    cout \u003c\u003c endl;\n    cout \u003c\u003c add(12,13) \u003c\u003c endl;\n    return 0;\n}\n```\n当然了，C++ 编写的库，C 是无法直接调用的。那如果 C 想调用 C++的库， 应该怎么做呢？请接着往下看。\n\n### C 调用 C++ 库\n\nC 调用 C++ 的库，一般不能直接调用，需要将 C++ 库转换成 C 接口(也就是要用`extern \"C\"`)输出，才可以用 C 来调用，这里举个例子(比如 C++ 中的“类”)：  \n\n```c++\n#include \u003ciostream\u003e\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n    int here();\n#ifdef __cplusplus\n}\n#endif\n\nusing namespace std;\n\nclass Hi {\n    public:\n    int hello() {\n        cout \u003c\u003c \"here() is called\" \u003c\u003c endl;\n    }\n};\n\nint here() {\n    Hi hh;\n    hh.hello();\n    return 0;\n}\n\n```\n\nCMakeLists.txt 内容不再赘述。  \n\n接下来只简单说一下它的显示调用：  \n\n```c\n#include \u003cstdio.h\u003e\n#include \u003cdlfcn.h\u003e\n\nint main()\n{\n    int (*dlfunc)();\n    void *handle;  //定义一个句柄\n    handle = dlopen(\"./libcppso.so\", RTLD_LAZY);//获得库句柄\n    dlfunc = dlsym(handle, \"here\"); //获得函数入口\n    (*dlfunc)();\n    dlclose(handle); \n\n    return 0;\n}\n```\n\n运行输出如下：  \n\n```\nhere() is called\n```\n\n\n\n### CMake 相关:       \n\u003e [CMake Wiki](https://cmake.org/Wiki/CMake)  \n\u003e [CMake 常用命令和变量](http://elloop.github.io/tools/2016-04-10/learning-cmake-2-commands)  \n\u003e [CMake使用进阶](http://linghutf.github.io/2016/06/16/cmake/)    \n\u003e [CMake 简要教程--相关工具对比](http://reyoung.me/post/cmake_talk_1/)    \n\n### Make 相关\n\nMakefile + make 为 Unix-like 环境下的项目管理工具(抽象程度低)。对于如何使用 Makefile 编译动态库和静态库，可参考这篇文章：[linux编译动态库和静态库的makefile示例](http://blog.csdn.net/shaoxiaohu1/article/details/46943417) 。需要说明一点：**cmake 也是根据 CMakeLists.txt 文件去生成 Makefile 的** (可以跨平台生成对应平台能用的 Makefile) 。而且 cmake 是抽象层次更高的项目管理工具。当你需要编译一个大项目，而大项目各文件的依赖关系复杂，Makefile 并不好写，这时使用 cmake 则很方便。\n\n### 链接、装载与库相关\n\n可以看看《程序员的自我修养——链接、装载与库》这本书。","cover":"","link":"./post/2016/11/05/linux-shared-object.html","preview":"\u003cp\u003e尝试了一下，Windows 下 Codeblocks 利用 Mingw 编译器编写动态链接库，结果虽然 dll 是生成了，但过程还是不太满意。因为 dll 是 Windows 下才用到的，似乎用 GNU 的编译器不太合适，最终还是改用 VS2015 (虽然它很‘臃肿’)。\u003c/p\u003e\n","title":"Linux 下用 Clion 编写及调用共享库的实践"},{"content":"\n『聰明的輸入法懂我心意』，正如 [RIME](http://rime.im/) 官网所说得那样。Windows 平台下叫『小狼毫』(英文名:Weasel) ,Linux 平台下叫『中州韻』(英文名:Rime)，MAC 平台叫『鼠鬚管』(英文名:Squirrel)，当然也有 Android 版的，叫『同文』。我个人觉得是输入法中做得非常独特的一个，做得非常好，用着非常舒服。  \n\n下面我先来说说 Linux 下的安装：  \n\n首先我 Linux 上的输入法框架是`fctix`,所以我安装`fctix-rime`。(注意，最好不要在 Linux 上安装多个输入法框架)只需一条命令(debian 系列及其衍生版)就可以了：  \n\n```\nsudo apt install fcitx-rime\n```\n然后注销重新登录就可以尽情使用了。  `fcitx-rime`的更多内容，可参阅 [fcitx-rime](https://github.com/fcitx/fcitx-rime)。  \n对于是 ibus 框架的，请参考这里[RimeWithIBus](https://github.com/rime/home/wiki/RimeWithIBus)。  \n\n再提一下 Windows 下的安装：  \n\n如果是 Windows7 及以下，则直接可以在官网下载使用。若是 Windows8及以上，包括 Windows10，很不幸，其兼容性不好，卡 modern 界面。但是有解决方案，目前其中一种解决方案是 [PRIME](https://github.com/osfans/PRIME) ,这其中还带来了 emoji 输入。  但切换输入法时很卡，使用时也稍有卡顿。\n\n![PRIME](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/prime.png)  \n\n另外一种就是 改进版 的 Rime，目前可在官方的 appveyor 持续集成中的 [artifacts](https://ci.appveyor.com/project/rime/weasel/build/artifacts) 下载。\n\n\n至于如何去配置，我简单说几个重要的地方，然后就去看 [Wiki](https://github.com/rime/home/wiki/UserGuide) 好了。\n\n- 修改配置时，不建议直接修改`default.yaml`或是`weasel.yaml` ，这两文件路径在 rime 安装路径的 `data` 目录下。这样的坏处是如果更新输入法，先前的改动可能会被覆盖而失效。\n- 修改保存之后要重新部署。操作步骤：在 Windows开始菜单中，找到`小狼毫輸入法`这个目录，进去之后点击`【小狼毫】重新部署`即可。\n- 添加自定义设置时，改`C:\\Users\\XXX\\AppData\\Roaming\\Rime\\default.custom.yaml`. 和`C:\\Users\\XXX\\AppData\\Roaming\\Rime\\weasel.custom.yaml`内容即可，不要忘了再**重新部署**。\n- 提供`default.custom.yaml`和`weasel.custom.yaml` 样例：  \n\ndefault.custom.yaml:   \n```yaml\ncustomization:\n  distribution_code_name: Weasel\n  distribution_version: 0.9.30\n  generator: \"Rime::SwitcherSettings\"\n  modified_time: \"Tue Feb 27 18:56:22 2018\"\n  rime_version: 1.2.10\npatch:\n  schema_list:\n    - {schema: luna_pinyin}\n    - {schema: cangjie5}\n    - {schema: luna_pinyin_fluency}\n    - {schema: luna_pinyin_simp}\n    - {schema: luna_pinyin_tw}\n    - {schema: bopomofo}\n    - {schema: bopomofo_tw}\n    - {schema: luna_quanpin}\n    \n  menu/page_size: 7\n```  \nweasel.custom.yaml:  \n```yaml\ncustomization:\n  distribution_code_name: Weasel\n  distribution_version: 0.9.30\n  generator: \"Weasel::UIStyleSettings\"\n  modified_time: \"Tue Feb 27 20:42:22 2018\"\n  rime_version: 1.2.10\npatch:\n  \"style/color_scheme\": rimeblue\n  \"style/inline_preedit\": true\n  \"style/layout/border_width\": 0\n```\n- 提供一个配色方案：\n#### rimeblue\n```yaml\nrimeblue:\n  name: \"RimeBlue\"\n  horizontal: false                           # 候选条横向显示\n  inline_preedit: true                        # 启用内嵌编码模式，候选条首行不显示拼音\n  candidate_format: \"%c.\\u2005%@\\u2005\"       # 用 1/6 em 空格 U+2005 来控制编号 %c 和候选词 %@ 前后的空间。\n  corner_radius: 10                            # 候选条圆角半径\n  border_height: 0                            # 窗口边界高度，大于圆角半径才生效\n  border_width: 12                            # 窗口边界宽度，大于圆角半径才生效\n  back_color: 0x4F4F4F                        # 候选条背景色\n  line_spacing: 0                             # 候选词的行间距\n  # spacing: 3                                  # 在非内嵌编码模式下，预编辑和候选词之间的间距\n  border_color: 0xE0B693                      # 边框色\n  font_face: \"PingFangSC-Regular\"             # 候选词字体\n  font_point: 20                              # 预选栏文字字号\n  label_font_face: \"PingFangSC-Regular\"       # 候选词编号字体\n  label_font_point: 20                        # 预选栏编号字号\n  text_color: 0xFFFFFF                        # HEX颜色代码，但是要注意顺序是蓝绿红（倒序）0xBBGGRR\n  candidate_text_color: 0xFFFFFF              #非第一候选项\n  hilited_candidate_back_color: 0xD1BA53      #第一候选项背景\n  hilited_candidate_text_color: 0xFFFFFF      #第一候选项\n```\n  来源：https://www.v2ex.com/t/413553\n  效果如图：\n  ![rimeblue](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/color_scheme_rimeblue.png)\n- 在线 Rime 配色方案编辑 [RIME See Me](https://rime.netlify.com) 。\n\n阅读材料：[Windows 输入法的 metro 应用兼容性改造](https://hcyue.me/2018/01/13/Windows%20%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%20metro%20%E5%BA%94%E7%94%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E6%94%B9%E9%80%A0/#more) ","cover":"","link":"./post/2016/11/01/rime.html","preview":"\u003cp\u003e『聰明的輸入法懂我心意』，正如 RIME 官网所说得那样。\u003c/p\u003e\n","title":"谈谈 RIME "},{"content":"\n今年1月份就想写个关于如何用 [rEFInd](http://www.rodsbooks.com/refind/) 管理多系统引导，但是一直拖到现在。回到正题，rEFInd 相当于一个菜单，开机进入这个菜单，选择菜单上的某个系统进入就可以了。当然它的魅力不仅在于此，还在于如果此时你挂载一个 U 盘或者移动硬盘,里面装了你喜欢的操作系统，硬件识别之后 ，rEFInd 也会在菜单上显示出来。  \n![图片来自于贴吧，非默认主题](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/refind-interface.jpg)  \n\n对于默认主题，配置文件`refind.conf`文件可以这样写：  \n```\n#设置默认时间5s，时间到后进入默认操作系统。\n#0表示一直等待选择\ntimeout 5\n\nscan_driver_dirs EFI/refind/drivers_x64\n\nscanfor manual,external,optical\n\ndefault_selection Windows 10\n\nmenuentry \"Windows 10\" {\n\ticon \\EFI\\refind\\icons\\os_win10.png\n    loader \\EFI\\Microsoft\\Boot\\bootmgfw.efi\n}\t\n\nmenuentry \"Linux Mint\"{\n\ticon /EFI/refind/icons/os_linuxmint.png\n    loader /EFI/ubuntu/shimx64.efi\n}\n```\n注：`shimx64.efi`这个引导文件是已经加过签名的，而`grubx64.efi`则没有。因此，使用`shimx64.efi`后是可以开启 BIOS 的`secure boot`的 。\n**若开启了`secure boot`，还需在 BIOS 中加入 rEFInd 的证书，是这个两个文件`refind.cer`和`refind.crt` **。\n\nWindows 用户可以使用 DiskGenius 和 [BOOTICE](http://www.ipauly.com/2015/11/15/bootice/) (可以修改多系统启动顺序，另外它还有其他主要功能) 这两个工具进行相关的设置。\n\nLinux 用户可使用 efibootmgr 管理 efi 启动项(添加、删除、改变顺序): `sudo efibootmgr -o 0000,0002,0001,0003`\n\n```\nBootCurrent: 0001\n\nTimeout: 2 seconds\n\nBootOrder: 0000,0002,0001,0003\n\nBoot0000* rEFInd\n\nBoot0001* ubuntu\n\nBoot0002* Windows Boot Manager\n\nBoot0003* ubuntu\n```\n\n说明：\n\n- 创建一个新的boot option \n  `efibootmgr -c`\n- 修改boot 顺序 \n  `efibootmgr -o X,Y,Z` \n- 启用/禁用boot option \n  `efibootmgr -a -b X`          启用标号为X的启动项 \n  `efibootmgr -A -b X`          禁用标号为X的启动项","cover":"","link":"./post/2016/10/28/refind.html","preview":"\u003cp\u003erEFInd 相当于一个菜单，开机进入这个菜单，选择菜单上的某个系统进入就可以了。\u003c/p\u003e\n","title":"用 rEFInd 管理多系统引导"},{"content":"\n\n教大家用 Hugo 建个人博客的文章太多了，这次我要介绍的是用 Gitlab-ci 自动部署( 持续集成 ) Hugo blog 到 Github Pages 上 (P.S. 当然前提是你必须有 Gitlab 账号哦 )，其核心就是一个配置文件`.gitlab-ci.yml`:  \n```\n# alpine linux \n#其包管理是 apk\nimage: alpine:3.4\n\nbefore_script:\n  - apk update \n  - apk add openssl \u0026\u0026 apk add git \u0026\u0026 apk add nodejs\n  - npm install\n  - wget https://github.com/spf13/hugo/releases/download/v0.16/hugo_0.16_linux-64bit.tgz\n  - echo \"37ee91ab3469afbf7602a091d466dfa5  hugo_0.16_linux-64bit.tgz\" | md5sum -c\n  - tar xf hugo_0.16_linux-64bit.tgz \u0026\u0026 cp ./hugo /usr/bin\n  - hugo version\n\npages:\n  cache:\n    paths:\n    - node_modules/\n\n  script:\n  - git clone https://\u003cyour personal access tokens\u003e@github.com/\u003cyour user name\u003e/\u003cyour repository name\u003e public\n  - npm run build\n  - cd ./public\n  - git config user.name \"\u003cyour user name\u003e\"\n  - git config user.email \"\u003cyour email\u003e\"\n  - git config --global push.default simple\n  - git add .\n  - git commit -m \"update site\"\n  - git push --set-upstream \"https://\u003cyour personal access tokens\u003e@github.com/\u003cyour user name\u003e/\u003cyour repository name\u003e\"\n  artifacts:\n    paths:\n    - public\n  only:\n  - master\n```  \n我这里使用的是 Hugo 的 1.6 版本，当然你也可以安装当前最新的 1.7 版本。  \n由于我使用了`gulp`压缩 html 和 js 文件，所以需要安装`nodejs`。下面是`gulp`的配置文件`gulpfile.babel.js`的内容：  \n```\nimport gulp from 'gulp'\nimport htmlmin from 'gulp-htmlmin'\nimport uglify from 'gulp-uglify'\nimport runSequence from 'run-sequence'\nimport shell from 'gulp-shell'\n\ngulp.task('hugo-build', shell.task(['hugo']))\n\ngulp.task('minify-html', () =\u003e {\n  return gulp.src('public/**/*.html')\n    .pipe(htmlmin({\n      collapseWhitespace: true,\n      minifyCSS: true,\n      minifyJS: true,\n      removeComments: true,\n      useShortDoctype: true,\n    }))\n    .pipe(gulp.dest('./public'))\n})\n\ngulp.task('minify-js', () =\u003e {\n    return gulp.src('./public/**/*.js')\n        .pipe(uglify())\n        .pipe(gulp.dest('./public'));\n});\n\ngulp.task('build', ['hugo-build'], (callback) =\u003e {\n  runSequence('minify-html','minify-js', callback)\n})\n```\n这里用`gulp-shell`这个包，执行`hugo`这个命令。  \npackage.json的内容:\n```\n{\n  \"private\": true,\n  \"scripts\": {\n    \"build\": \"gulp build\"\n  },\n  \"devDependencies\": {\n    \"babel-preset-es2015\": \"^6.5.0\",\n    \"babel-register\": \"^6.5.2\",\n    \"gulp\": \"^3.9.1\",\n    \"gulp-cli\": \"^1.2.1\",\n    \"gulp-htmlmin\": \"^1.3.0\",\n    \"gulp-uglify\": \"^2.0.0\",\n    \"gulp-shell\": \"^0.5.2\",\n    \"run-sequence\": \"^1.1.5\"\n  },\n  \"babel\": {\n    \"presets\": [\n      \"es2015\"\n    ]\n  }\n}\n```  \n由于`gulpfile.babel.js`采用`ECMAScript 6`标准，使用了最新的 JavaScript 语法，需要用`babeljs`将其语法转化。  \n这些做完之后就可以在`.gitlab-ci.yml`中用`npm run build`部署你的 blog 了。","cover":"","link":"./post/2016/10/17/gitlab-ci.html","preview":"\u003cp\u003e教大家用 Hugo 建个人博客的文章太多了，这次我要介绍的是用 Gitlab-ci 自动部署( 持续集成 ) Hugo blog 到 Github Pages 上\u003c/p\u003e\n","title":"通过 Gitlab-ci 将 Hugo blog 自动部署至 GitHub "},{"content":"\n\n  近日，想在 Windows 系统下编译 Linux-0.11 内核。 于是就在 VirtualBox 中安装了 [Alpine Linux](http://alpinelinux.org/) 3.4 。  \n  其中 VirtualBox 下的网络配置(双网卡)如下：  \n使用2块网卡，第一块设置为`host-only`方式：  \n![vbox-network-1](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/vbox-network-1.png)  \n  第二块设置为`nat`方式：\n![vbox-network-2](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/vbox-network-2.png)  \n  其中，VirtualBox Host-Only Ethernet Adapter 的配置如下：  \n![vbox-hostonly](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/vbox-hostonly.png)   \n\n![vbox-hostonly-ipv4](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/vbox-hostonly-ipv4.png)  \n  其中, DNS 服务器地址设置和本地上网的设置相同。   IP 地址是自动生成，也可手动修改。这里我使用的是阿里的公共 DNS 。  \n  然后登陆 Alpine Linux ，查看 MAC 地址是否和在 VirtualBox 中网络设置中的 MAC 地址一样。\n![alpine-network](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/alpine-network.png)  \n  这样主机和虚拟机就可以互 ping ，主机还可通过   ssh 连接虚拟机。例如：`ssh root@192.168.56.101`   (ps. 我用的是 [cmder](http://cmder.net/) 上的 ssh 工具)。  \n\n\u003e* 推荐1： 在 Windows 上可以用 [SSH Secure Shell Client](http://www.wm.edu/offices/it/services/software/licensedsoftware/webeditingsftp/sshsecureshell/index.php) 这个工具替代`scp`命令在主机和虚拟机之间传输文件。  \n\u003e   ![SSHSecureShellClient](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/SSHSecureShellClient.png)   \n\u003e* 推荐2： 在 Windows 上还可以用 [WinScp](https://winscp.net/eng/docs/lang:chs) 这个工具在主机和虚拟机之间传输文件。  \n\n\n  到这儿，都是些准备工作，接下来才是本文要说的东西。  \n由于 linux 0.11 (原版)内核编译需要 gcc3.4.6  ,而这个 gcc 版本太老了。于是就出现了 linux 0.11-gcc4 这个版本(网上可以搜到),可以用 gcc4.x 去编译。在我的 Linux Mint 18 上，修改了几个错误之后，用自带的 gcc5.4.0 编译成功了（此处为我修改的[源码](https://cdn.rawgit.com/qanno/qanno.github.io/master/downloads/linux-gcc5.4.0.zip)，如果还有错误编译不通过，请参考[这篇文章](http://www.voidcn.com/blog/hjq842382134/article/p-5955492.html)），我不甘心，我想用更高的 gcc 版本去完成这件事。在 Gihub 上 search   了一番，发现了这个：[Linux-0.11](https://github.com/yuanxinyu/Linux-0.11)，这个修改版我终于在 Alpine Linux 上编译成功了（如果遇到： \"make: execvp: /tools/build.sh Permission denied .\" 请修改build.sh的权限。）。\n  最后，用 [bochs](http://bochs.sourceforge.net) 模拟启动成功了。  \n  ![bochs-linux0.11](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/bochs-linux0.11.png)\n其中 bochs 的 bxrc 文件：  \n```\n#BIOS映像文件和VGA BIOS映像文件\n#XXX为Bochs的安装盘\nromimage: file=XXX:\\Bochs-2.6.8\\BIOS-bochs-latest\n#运行内存\nmegs: 64\nvgaromimage: file=XXX:\\Bochs-2.6.8\\VGABIOS-lgpl-latest\n#这个是启动软盘\nfloppya: 1_44=C:\\Users\\xxxx\\Desktop\\Image,status=inserted\nata0-master: type=disk, path=\"C:\\Users\\xxxx\\Desktop\\linux_0_11-master\\hdc-0.11.img\", mode=flat, cylinders=204, heads=16, spt=38\n#确定启动方式\nboot: c\nlog: C:\\Users\\xxxx\\Desktop\\bochsout.txt\ncpu: count=1, ips=1000000\n```\n","cover":"","link":"./post/2016/10/10/compile-linux-kernal.html","preview":"\u003cp\u003e近日，想在 Windows 系统下编译 Linux-0.11 内核。 于是就在 VirtualBox 中安装了 Alpine Linux 3.4\u003c/p\u003e\n","title":"在 Alpine Linux 上编译 Linux0.11 内核"},{"content":"\n\n　　用`python`实现了一个带参数的命令行将图片转换成`progressive encoding`(渐进式) JPEG 格式。  \n　　这里先贴出代码：  \n```python\n#! python3\nimport platform, sys, os\nimport getopt\nfrom PIL import Image ,ImageFile\n\ndef isWindows():\n    return 'Windows' in platform.system()\n \ndef isLinux():\n    return 'Linux' in platform.system()\n\ndef usage():\n    print (\"-h: This message.\")\n    print (\"-i [file]: the path of the target image file. \")\n    print (\"-o [filepath]: the path of the output. \")\n    print (\"EXAMPLES:\")\n    print (\"$py tojpeg.py -i /home/test.jpg - o /home\")\n\ndef info():\n    print (\"**************************************************\")\n    print (\"**|''''''''''''''''''''''''''''''''''''''''''''|**\")\n    print (\"**|convert images to progressive encoding JPEG |**\")\n    print (\"**|Version: 1 beta                             |**\")\n    print (\"**|By: zetao yang                              |**\")\n    print (\"**|Email: yangzetao2015[@] outlook             |**\")\n    print (\"**|https://zetaoyang.github.io                 |**\")\n    print (\"**|-                                           |**\")\n    print (\"**|Usage: $tojpeg -h                           |**\")\n    print (\"**|                                            |**\")\n    print (\"**|,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,|**\")\n    print (\"**************************************************\")\n    print (\"\")\n\nif(isWindows()):\n   os.system(\"cls\")\nif(isLinux()):\n   os.system(\"clear\")\n\ndef main():\n    info()\n    try:\n        #使用sys.argv[1:] 过滤掉第一个参数\n        #（它是执行脚本的名字，不应算作参数的一部分）\n        opts,args = getopt.getopt(sys.argv[1:],\"hi:o:\", [\"help\",\"input=\" ,\"output=\"])\n    except getopt.GetoptError as err:\n        print (err)\n        sys.exit(2)\n\n    if not opts and not args:\n        usage()\n        sys.exit()\n\n    for opt, arg in opts:\n        if opt in (\"-h\",\"--help\"):\n            usage()\n            sys.exit()\n        elif opt in (\"-i\",\"--input\"):\n            input_file = arg\n        elif opt in (\"-o\",\"--output\"):\n            output_path = arg\n        else:\n            assert False, \"unhandled option\"\n\n    try:\n        img = Image.open(input_file)\n        destination = output_path + \"/output.jpeg\"\n        try:\n            img.save(destination,\"JPEG\",quality=80,optimize=True,progressive=True)\n            print(\"conversion is ok.\")\n        except IOError:\n            ImageFile.MAXBLOCK = img.size[0]*img.size[1]\n            img.save(destination,\"JPEG\",quality=80,optimize=True,progressive=True)\n    except KeyboardInterrupt:\n        print (\"\\nWell i hope you had a good time.\")\n        \nif __name__ == \"__main__\":\n    main()\n```  \n   最后可以用 [pyinstaller](https://github.com/pyinstaller/pyinstaller) 打包分发了。\n","cover":"","link":"./post/2016/10/09/progressive-encoding-jpeg.html","preview":"\u003cp\u003eusing python to generate progressive encoding JPEG\u003c/p\u003e\n","title":"生成渐进式 jpeg"},{"content":"\n\n　　 前几天，在 V2EX 看见有人用 Github API 基于python实现了一个图床。于是我决定用 nodejs 也实现一个类似功能。首先我看有没现成的第三方库，在 [Libraries | GitHub Developer Guide](https://developer.github.com/libraries/) 我发现有五个跟 javascript 相关的库：  \n\u003cdiv align=center\u003e\n![github-api-js](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/github-api-js.png)  \n\u003c/div\u003e\n经调研发现 [GitHub.js wrapper around the GitHub API](https://github.com/michael/github) 比较好入手，基本将 Github API 全都实现了，并且封装了自己的接口，但是缺点还是有的，文档写的不太详细。然后就开始看它的文档，其中 Repository 的 writeFile() 方法就是上传文件的函数。  \n其中 writeFile():  \n\u003cdiv align=center\u003e\n![github-api-writeFile-2.3.0](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/github-api-writeFile-2.3.0.png)  \n\u003c/div\u003e  \n　　 先在这里贴出代码( ECMAScript 2015 标准)： \n```javascript\n//导入github-api\nvar GitHub = require(\"github-api\")\nvar fs = require(\"fs\")\n\nconst gh = new GitHub({\n\ttoken: '\u003cyour personal token\u003e'//这里采用token认证\n})\n\nvar branch = '\u003cbranch_name\u003e'//eg. master\nvar ufilePath = '\u003crepo_path\u003e'//eg. images/\n//{master}/xxx.jpg\nvar ufileName = '\u003cfile_name\u003e'//eg. xxx.jpg\nvar commit = 'here i am'\nvar user = '\u003cuser name\u003e'//用户名\nvar repo = '\u003crepository name\u003e'//仓库名\n\nconst re = gh.getRepo(user,repo)\n\n//同步读取文件\nvar imageBlob = fs.readFileSync('\u003cfilepath\u003e')\n//base64编码\nvar imageB64 = imageBlob.toString('base64')\n//ascii编码\n//utf8编码也可以，只不过有些浪费。\nvar data = imageB64.toString('ascii')\n\nvar options = {\n    //author:{},\n    //commiter:{},\n    encode: false\n}\n\nre.writeFile(branch, ufilePath + ufileName, data , commit,options, (error,result,request)=\u003e{\n    if (error===null) {\tconsole.log(`https://cdn.rawgit.com/${user}/${repo}/${branch}/${ufilePath}${ufileName}`)\n\t }\n})\n\n```\n　　 这其中的关键就是编码问题， GitHub Contents API 要求 content 是 base64 编码。 \n\n\n​\t","cover":"","link":"./post/2016/10/08/github-api.html","preview":"\u003cp\u003e前几天，在 V2EX 看见有人用 Github API 基于python实现了一个图床。于是我决定用 nodejs 也实现一个类似功能。\u003c/p\u003e\n","title":"用 Github API 上传文件的方法"},{"content":"\n\n\u003e 建议先了解一下 RSA 原理，再看本文。推荐阮一峰老师的两篇文章：  \n\u003e* [RSA 算法原理（一）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)  \n\u003e* [RSA 算法原理（二）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)  \n\n因为`php`支持的密钥格式是`.pem`所以`web`和`java`端都要将`pem`格式转换成其语言平台支持的格式。 比如，`java`支持的格式默认是`.asn`。   \n### 密钥对的生成( php )  \n\nRSA 的密钥是由两个数字组成。生成这些密钥有 3 步：  \n1. 创建两个随机的非常大的质数。这两个数字分别称为 p 和 q 。将 p 和 q 相乘得到一个数字，把它称做 n 。  \n2. 创建一个随机数，称为 e ，使它与 (p-1)*(q-1) 互质。  \n3. 计算 e 的模逆，这个数字称为 d 。  \n(n 和 e 组成公钥，n 和 d 组成私钥。两个密钥都包含了数字 n 。)    \n虽然可以正确地实现 RSA 算法，但还有一些微妙的错误会导致加密消息遭到破译。所以还是要基于一些专业的第三方库或软件，比如`openssl`，来实现加密数据。    \n\n如果系统是`Linux`的话，可以使用`openssl`命令来生成。这里展示的是在`Windows`系统下的操作(因为当时做这个东西的时候是在 Windows 8.1 系统下完成的)，使用 [xampp](https://www.apachefriends.org/zh_cn/index.html) 集成好的`openssl`(其配置文件路径在 xampp 的安装路径下的php\\extras\\openssl\\openssl.cnf，我们这次使用的就是这个文件)，下面展示用`php`来生成密钥对：    \n```php\n\u003c?php\n//OPENSSL_CNF为 openssl.cnf 的路径\ndefine('OPENSSL_CNF','\u003cyour openssl.cnf path \u003e');\ndefine('SHA',\"sha512\");\ndefine('LENGTH',2048);\n\nheader(\"Content-type:text/html;charset=utf-8\");\n$configargs=array(\n\t'config'=\u003e OPENSSL_CNF,\n\t\"digest_alg\" =\u003e SHA,\n    \"private_key_bits\" =\u003e LENGTH,\n    \"private_key_type\" =\u003e OPENSSL_KEYTYPE_RSA,);\n$res=openssl_pkey_new($configargs);\nopenssl_pkey_export($res,$pri,null, $configargs);\n\n/*Binary Data to Decimal Data\n * @param string $data\n * @return string $result\n * */\nfunction hexTobin($hexString) \n    { \n        $hexLenght = strlen($hexString); \n        // only hexadecimal numbers is allowed \n        if ($hexLenght % 2 != 0 || preg_match(\"/[^\\da-fA-F]/\",$hexString)) return FALSE; \n\n        unset($binString); \n        for ($x = 1; $x \u003c= $hexLenght/2; $x++) \n        { \n                $binString .= chr(hexdec(substr($hexString,2 * $x - 2,2))); \n        } \n\n        return $binString; \n    } \n \n/* Binary Data to Decimal Data\n * @param string $data\n * @return string $result\n **/\nfunction binTodec($data)\n\t{\n\t\t$base = \"256\";\n\t\t$radix = \"1\";\n\t\t$result = \"0\";\n\n\t\tfor($i = strlen($data) - 1; $i \u003e= 0; $i--)\n\t\t{\n\t\t\t$digit = ord($data{$i});\n\t\t\t$part_res = bcmul($digit, $radix);\n\t\t\t$result = bcadd($result, $part_res);\n\t\t\t$radix = bcmul($radix, $base);\n\t\t}\n\n\t\treturn $result;\n\t}\n\n$details=openssl_pkey_get_details($res);\n\n$n_hex=bin2hex($details['rsa']['n']);\n$d_hex=bin2hex($details['rsa']['d']);\n$e_hex=bin2hex($details['rsa']['e']);\n\n$n_dec=binTodec($details['rsa']['n']);\n$d_dec=binTodec($details['rsa']['d']);\n$e_dec=binTodec($details['rsa']['e']);\n\nopenssl_pkey_free($res);\n\n$pub=$details['key'];\n\n$crtpath = \"./test.crt\"; //公钥文件路径  \n$pempath = \"./test.pem\"; //私钥文件路径  \n\n$n_hexpath = \"./n_hex.key\"; //n_hex文件路径  \n$d_hexpath = \"./d_hex.key\"; //d_hex文件路径  \n$e_hexpath = \"./e_hex.key\"; //e_hex文件路径 \n\n$n_decpath = \"./n_dec.key\"; //n_dec文件路径  \n$d_decpath = \"./d_dec.key\"; //d_dec文件路径  \n$e_decpath = \"./e_dec.key\"; //e_dec文件路径 \n\n//生成证书文件  \n$fp = fopen($crtpath, \"w\");  \nfwrite($fp, $pub);  \nfclose($fp);  \n\n$fp = fopen($pempath, \"w\");  \nfwrite($fp, $pri);  \nfclose($fp);  \n//生成n_hex,d_hex,e_hex文件\n$fp = fopen($n_hexpath, \"w\");  \nfwrite($fp, $n_hex);  \nfclose($fp);  \n\n$fp = fopen($d_hexpath, \"w\");  \nfwrite($fp, $d_hex);  \nfclose($fp);  \n\n$fp = fopen($e_hexpath, \"w\");  \nfwrite($fp, $e_hex);  \nfclose($fp); \n//生成n_dec,d_dec,e_dec文件\n$fp = fopen($n_decpath, \"w\");  \nfwrite($fp, $n_dec);  \nfclose($fp);  \n\n$fp = fopen($d_decpath, \"w\");  \nfwrite($fp, $d_dec);  \nfclose($fp);  \n\n$fp = fopen($e_decpath, \"w\");  \nfwrite($fp, $e_dec);  \nfclose($fp); \n\nvar_dump($pub);\necho \"\u003cbr/\u003e\";\nvar_dump($pri);\n$pu_key = openssl_pkey_get_public($pub);\nprint_r($pu_key);\necho \"\u003cbr/\u003e\";\n$data = 'plaintext data goes here.';\n\n// Encrypt the data to $encrypted using the public key\nopenssl_public_encrypt($data, $encrypted,$pub,OPENSSL_PKCS1_PADDING);\n\n// Decrypt the data using the private key and store the results in $decrypted\nopenssl_private_decrypt($encrypted, $decrypted, $pri,OPENSSL_PKCS1_PADDING);\n\necho $encrypted.\" \".strlen($encrypted).\"   \".base64_encode($encrypted).\"\u003cbr/\u003e\";\necho $decrypted;\n?\u003e\n```  \n### java\n\u003e 此处的核心代码是我从互联网上搜索到的，出处已经记不清是哪了，还请原作者见谅。  \n\n```java\nprivate String _key;\nprivate KeyFormat _format;\nprivate Cipher _decryptProvider;\nprivate Cipher _encryptProvider;\n\npublic KeyWorker(String key) {\n\tthis(key, KeyFormat.ASN);\n}\n\npublic KeyWorker(String key, KeyFormat format) {\n\tthis._key = key;\n\tthis._format = format;\n}\n\npublic String encrypt(String data) throws IllegalBlockSizeException,\nBadPaddingException, InvalidKeyException, NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeySpecException, IOException, SAXException, ParserConfigurationException {\n\tthis._makesureEncryptProvider();\n\tbyte[] bytes = data.getBytes(\"UTF-8\");\n\tbytes = this._encryptProvider.doFinal(bytes);\n\treturn new BASE64Encoder().encode(bytes);\n}\n\npublic String decrypt(String data) throws IOException,\nIllegalBlockSizeException, BadPaddingException,\nInvalidKeyException, NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeySpecException, SAXException, ParserConfigurationException {\n\tthis._makesureDecryptProvider();\n\t\n\tbyte[] bytes = new BASE64Decoder().decodeBuffer(data);\n\tbytes = this._decryptProvider.doFinal(bytes);\n\treturn new String(bytes, \"UTF-8\");\n}\n\nprivate void _makesureDecryptProvider() throws NoSuchAlgorithmException,\nNoSuchPaddingException, IOException, InvalidKeySpecException,\nInvalidKeyException, SAXException, ParserConfigurationException {\nif (this._decryptProvider != null)\n\treturn;\n\nCipher deCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\nswitch (this._format) {\n\ncase PEM: {\n\tthis._key = this._key.replace(\"-----BEGIN PUBLIC KEY-----\", \"\")\n\t\t\t.replace(\"-----END PUBLIC KEY-----\", \"\")\n\t\t\t.replace(\"-----BEGIN PRIVATE KEY-----\", \"\")\n\t\t\t.replace(\"-----END PRIVATE KEY-----\", \"\")\n\t\t\t.replaceAll(\"\\r\\n\", \"\");\n}\ncase ASN:\ndefault: {\n\tBoolean isPrivate = this._key.length() \u003e 500;\n\tif (isPrivate) {\n\t\tPKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(\n\t\t\t\tnew BASE64Decoder().decodeBuffer(this._key));\n\n\t\tKeyFactory factory = KeyFactory.getInstance(\"RSA\");\n\t\tRSAPrivateKey privateKey = (RSAPrivateKey) factory\n\t\t\t\t.generatePrivate(spec);\n\t\tdeCipher.init(Cipher.DECRYPT_MODE, privateKey);\n\t} else {\n\t\tX509EncodedKeySpec spec = new X509EncodedKeySpec(\n\t\t\t\tnew BASE64Decoder().decodeBuffer(this._key));\n\n\t\tKeyFactory factory = KeyFactory.getInstance(\"RSA\");\n\t\tRSAPublicKey publicKey = (RSAPublicKey) factory\n\t\t\t\t.generatePublic(spec);\n\t\tdeCipher.init(Cipher.DECRYPT_MODE, publicKey);\n\t}\n}\n\tbreak;\n}\n\nthis._decryptProvider = deCipher;\n}\n\nprivate void _makesureEncryptProvider() throws NoSuchAlgorithmException,\nNoSuchPaddingException, IOException, InvalidKeySpecException,\nInvalidKeyException, SAXException, ParserConfigurationException {\nif (this._encryptProvider != null)\n\treturn;\n\nCipher enCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\nswitch (this._format) {\n\ncase PEM: {\n\tthis._key = this._key.replace(\"-----BEGIN PUBLIC KEY-----\", \"\")\n\t\t\t.replace(\"-----END PUBLIC KEY-----\", \"\")\n\t\t\t.replace(\"-----BEGIN PRIVATE KEY-----\", \"\")\n\t\t\t.replace(\"-----END PRIVATE KEY-----\", \"\")\n\t\t\t.replaceAll(\"\\r\\n\", \"\");\n}\ncase ASN:\ndefault: {\n\tBoolean isPrivate = this._key.length() \u003e 500;\n\tif (isPrivate) {\n\t\tPKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(\n\t\t\t\tnew BASE64Decoder().decodeBuffer(this._key));\n\n\t\tKeyFactory factory = KeyFactory.getInstance(\"RSA\");\n\t\tRSAPrivateKey privateKey = (RSAPrivateKey) factory\n\t\t\t\t.generatePrivate(spec);\n\t\tenCipher.init(Cipher.ENCRYPT_MODE, privateKey);\n\n\t} else {\n\t\tX509EncodedKeySpec spec = new X509EncodedKeySpec(\n\t\t\t\tnew BASE64Decoder().decodeBuffer(this._key));\n\n\t\tKeyFactory factory = KeyFactory.getInstance(\"RSA\");\n\t\tRSAPublicKey publicKey = (RSAPublicKey) factory\n\t\t\t\t.generatePublic(spec);\n\t\tenCipher.init(Cipher.ENCRYPT_MODE, publicKey);\n\t}\n}\n\tbreak;\n}\n\t\tthis._encryptProvider = enCipher;\n\t}\n```  \n以上代码核心就是将其它密钥格式转换成`.pem`格式，和`php`后台那边适配。    \n### web  \n由于是前端，所以只做加密数据。然后必须先将密钥对‘分解’成 'n' , 'd' , 'e'。上代码：  \n```html\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n\u003cmeta charset=\"UTF-8\"\u003e\n\u003ctitle\u003eJavaScript RSA Encryption \u003c/title\u003e\n\u003c/head\u003e\n \n\u003cscript language=\"JavaScript\" type=\"text/javascript\" src=\"./js/jsbn.js\"\u003e\u003c/script\u003e\n\u003cscript language=\"JavaScript\" type=\"text/javascript\" src=\"./js/prng4.js\"\u003e\u003c/script\u003e\n\u003cscript language=\"JavaScript\" type=\"text/javascript\" src=\"./js/rng.js\"\u003e\u003c/script\u003e\n\u003cscript language=\"JavaScript\" type=\"text/javascript\" src=\"./js/rsa.js\"\u003e\u003c/script\u003e\n\u003cscript language=\"JavaScript\" type=\"text/javascript\" src=\"./js/base64.js\"\u003e\u003c/script\u003e\n\u003cscript language=\"JavaScript\"\u003e \n//publc key  and public length hex data\nvar public_key=\"b3a55f5100b87959ef1bd60508fca4f547af9a0617e8eea1a69a9f7f3f669ee01d89033a7521fa25c6437c6e4c4e0237afc23dbc3f1597b3a0a2181b45aae5effbb787cf6ced26fc042168bad462d916323246ce923c6fa22b6baf62f2a8f93a753b21b3fcd4c5789d89ca02badb88081452a5ecc12d88374475bfa409627e9014600d1b821b76b8b44e6d43bf28eb9fbb68a7b40e5c778d8ff63798764277c040432b9b27a682c8e1c202e95e8c3b826d5188c389716bb4a7278761a7b22ff39ede130c1b9022449f190a79846ea616fec3e1056e8f24a7b3b508ca734ea2c8a92f2c97adc4afd391a52e04504fd69553b4e048650a44ebdaa889701256d315\";\nvar public_length=\"0010001\";\nfunction do_encrypt() {\n  var before = new Date();\n  var rsa = new RSAKey();\n  rsa.setPublic(public_key, public_length);\n  var res = rsa.encrypt(document.rsatest.plaintext.value);\n  var after = new Date();\n  if(res) {\n    document.rsatest.ciphertext.value =res;\n    document.rsatest.cipherb64.value = hex2b64(res);\n    document.rsatest.status.value = \"Time: \" + (after - before) + \"ms\";\n  }\n}\n\n\u003c/script\u003e\n \n\u003cform name=\"rsatest\" action=\"rsa.php\" method=\"post\"\u003e\nPlaintext (string):\u003cbr\u003e\n\u003cinput name=\"plaintext\" type=\"text\" value=\"test\" size=40\u003e\n\u003cinput type=\"button\" value=\"encrypt\" onClick=\"do_encrypt();\"\u003e\u003cp\u003e\nCiphertext (hex):(Not used)\u003cbr\u003e\n\u003ctextarea name=\"ciphertext\" rows=4 cols=70\u003e\u003c/textarea\u003e\u003cp\u003e\nCiphertext (base64):\u003cbr\u003e\n\u003ctextarea name=\"cipherb64\" rows=3 cols=70\u003e\u003c/textarea\u003e\u003cp\u003e\nStatus:\u003cbr\u003e\n\u003cinput name=\"status\" type=\"text\" size=40\u003e\u003cp\u003e\n\u003cinput type=\"submit\" value=\"submit\" /\u003e\n\u003c/form\u003e\n  \u003cbody\u003e\n\u003chtml\u003e\n```  \n  \n##### 对应的 php 后台解密：  \n```php\n\u003c?php \n//header(\"Content-type:text/javascript;charset=utf-8\");\n$encrypted=$_POST['cipherb64'];\n$public_key = file_get_contents(\"../public.crt\");\n$private_key = file_get_contents(\"../private.pem\");\n\n//var_dump(base64_decode($encrypted));\n\n$pu_key = openssl_pkey_get_public($public_key);//这个函数可用来判断公钥是否是可用的\n$pi_key = openssl_pkey_get_private($private_key);//这个函数可用来判断私钥是否是可用的，可用返回资源id Resource id\n//var_dump($pu_key);\n//var_dump($pi_key);\nopenssl_private_decrypt(base64_decode($encrypted),$decrypted,$pi_key);//私钥解密\necho \"\\n\";\nvar_dump($decrypted);\necho \"\\n\".\"共\".strlen($decrypted).\"个字节。\";\n?\u003e\n ```\n### 源代码分享\n以上全部代码在我的 Github 托管。[传送门](https://github.com/ZetaoYang/RSA)\n\n\n\n\n\n\n","cover":"","link":"./post/2016/10/06/rsa.html","preview":"\u003cp\u003e建议先了解一下 RSA 原理，再看本文。推荐阮一峰老师的两篇文章\u003c/p\u003e\n","title":"非对称加密( RSA )数据传送的实战"},{"content":"\n\n\u003e 本文是在众成翻译认领翻译的，原文链接在此 https://hacks.mozilla.org/2016/09/introducing-debugger-html/?utm_source=javascriptweekly\u0026utm_medium=email\n\n_debugger.html_ 是一个来自于 Mozilla 的现代 JavaScript 调试器， 它是由 [React](https://facebook.github.io/react/)和[Redux](http://redux.js.org/) 技术搭建的 web应用。该项目于今年年初开始，是为了取代 [Firefox Developer Tools](https://developer.mozilla.org/en/docs/Tools) 中目前的调试器。而且，我们也曾想过让一个调试器能调试多个目标并且工作在独立模式下。\n\n\n\n![collage of debugger targets](http://p9.qhimg.com/t01884f42bb9cc90d53.png)  \n\n\n\n目前， debugger.html 可以连接到并调试 Firefox ，而且还可以连接到 Chrome 和 Node(目前是实验性的)。调试器用 Mozilla 的[远程调试协议](https://wiki.mozilla.org/Remote_Debugging_Protocol)(RDP)( Mozilla’s Remote Debug Protocol)连接到 Firefox ,而与 Node、Chrome 则通过[Chrome远程调试协议](https://developer.chrome.com/devtools/docs/debugger-protocol)(Chrome’s RDP)通信。\n\ndebugger.html 项目托管在 [GitHub](https://github.com/devtools-html/debugger.html) 上而且使用现代框架和工具链，使其随时可以参阅，吸引广大的开发人员。\n\n# debugger.html\n\n用户界面分为三个主要区域: 源面板、编辑器面板和右边栏。\n\n*   _源面板_ 显示所有当前正在调试的应用程序的源代码树状图。\n\n*   _编辑器面板_ 用来显示项目的各种源文件并且提供设置断点和修饰美化源文件的功能。\n\n*   _右边栏_ 用于显示当调试器暂停调试时,当前的断点，当前的调用堆栈，以及限定了作用域的变量，集。\n\n*   调试器支持 pausing(暂停) ,step over(跳过) , step in(跳入) , step out(跳出) ,并且尽其所能调试 JavaScript。\n\u003e 译者注：  \n\u003e _step over_ 是指在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完在停止，也就是把子函数整个作为一步；  \n\u003e _step in_ 是指单步执行，遇到子函数就进入并且继续单步执行；  \n\u003e _step out_ 是指当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数。  \n\n*   _调用堆栈面板_ 显示调用堆栈帧的一个给定的暂停条件。_作用域面板_ 显示基于所选框架的展开变量树。\n\n\n\n![debug demonstration Gif](http://p2.qhimg.com/t01318b9b3656ffd49a.gif)\n\n\n\n# 入门\n\n若要开始使用调试器你可以查阅托管于 Github 的代码，也可以看[入门指南](https://github.com/devtools-html/debugger.html/blob/master/CONTRIBUTING.md#getting-started)。\n\n如果你想直接着手，运行以下命令︰\n\n```\nnpm install - Install dependencies\nnpm start - Start development web server\nopen http://localhost:8000 - Open in any modern browser\n```\n\n一旦你在8000端口打开了浏览器调试器，将显示调试器主页面，你可以从其列出的清单中选择任何可调试目标。为了使调试器进行连接和调试目标，调试器必须运行开启远程调试。这通常需要你启动设置一组标志的目标。例如，你可以启动 Firefox (以运行在MacOS上举例)，使用下面的命令开启远程调试︰\n\n```\n$ /Applications/Firefox.app/Contents/MacOS/firefox-bin\n--start-debugger-server 6080 -P development\n```\n\n关于 Chrome 和 Firefox 的其他操作列在[这里](https://github.com/devtools-html/debugger.html/blob/master/docs/remotely-debuggable-browsers.md#)。\n\n调试 Node 需要 node [6.3.0](https://nodejs.org/en/blog/release/v6.3.0/)或者以上版本环境。运行 Node ,你需要设置检查标志。例如，如果你想要调试 `myserver.js` 你需要使用类似于以下内容的命令。\n\n```\n`$ node --inspect myserver.js`\n```\n\n更多信息可以在[入门](https://github.com/devtools-html/debugger.html/blob/master/CONTRIBUTING.md#getting-started)指南里查阅\n\n# Firefox Developer Tools\n\n我们正在将此调试器集成到 Firefox 的[Developer Tools](https://developer.mozilla.org/en-US/docs/Tools)。第一代版本，已经在[Nightly](https://nightly.mozilla.org/)登陆了，你可以尝试一下。\n\n\n![example debugging jsfiddle](http://p9.qhimg.com/t016a6422793b28bd2f.png)\n\n\n\n# 参与进来\n\n正如上面所说的，此项目仍在开发中，我们将感谢您的帮助，使得最好的调试器成为可能。如果您有兴趣加入我们的工作，请看看[协助](https://github.com/devtools-html/debugger.html/blob/master/CONTRIBUTING.md)指南。\n\n## 关于\n[Bryan Clark](https://hacks.mozilla.org/author/bclarkmozilla-com/) \n\nFirefox Developer Tools 技术产品经理\n\n*   [@clarkbw](http://twitter.com/clarkbw)\n\n[更多文章 由 Bryan Clark…](https://hacks.mozilla.org/author/bclarkmozilla-com/)","cover":"","link":"./post/2016/10/01/t-debugger-html.html","preview":"\u003cp\u003e\u003cem\u003edebugger.html\u003c/em\u003e 是一个来自于 Mozilla 的现代 JavaScript 调试器， 它是由 React 和 Redux 技术搭建的 web应用。该项目于今年年初开始，是为了取代 Firefox Developer Tools 中目前的调试器。而且，我们也曾想过让一个调试器能调试多个目标并且工作在独立模式下。\u003c/p\u003e\n","title":"[译]介绍 debugger.html ★ Mozilla Hacks ——Web 开发人员博客"},{"content":"\n\n*以下方法适合于 Windows 用户，如果是 Linux或者 Mac 用户可以直接用终端的命令进行操作。*  \n\n#### 一、列出已存在的 ssh Key  \n方法1.打开 Git Bash，并且输入：  \n`ls ‐al ~/.ssh\n`  \n\n方法2.打开 [cmder](http://cmder.net/) ，并且输入：   \n`ls ‐al ~/.ssh\n`  \n\n#### 二、生成密钥   \n方法1.用 Git Bash，然后输入：  \n`ssh‐keygen ‐t rsa ‐C \"your_email@example.com\"\n`   \n\n这个命令将会生成一个以 your_email@example.com 为标签的 ssh key，然后 bash 中会显示：  \nGenerating public/private rsa key pair.\nEnter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]   \n\n*注*：此处私钥的名称可以自定义，即可以不使用默认的名称 ‘id_rsa’。\n另外还有一个常识，RSA 加密算法它的**公钥是从私钥提取而来**。\n\n直接回车，然后出现：  \nEnter passphrase (empty for no passphrase): [Type a passphrase]\nEnter same passphrase again: [Type passphrase again]   \n\n因为追求操作方便，所以不打算在 deploy 的时候输入这个 passphrase ，所以直接回车两次设为空。然后你会看到：  \n`Your identification has been saved in ~/.ssh/id_rsa.\n Your public key has been saved in ~/.ssh/id_rsa.pub.\nThe key fingerprint is:\n01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com\n`  \n\n#### 三、加入ssh Agent  \n\n下一步在 Git Bash 或者 cmder 中输入：\n\n`ssh‐agent ‐s\n`   \n\n如果出现类似 Agent pid XXXX 这样的字样，则跳过下一步，否则输入：  \n``eval `ssh‐agent ‐s`\n``\n\n*注*：此处用 cmder 可能会出现下面的提示  \nCmder - 'eval' command is not recognized   \n解决方法：使用`bash`命令进入\nbash shell。然后`eval`就可以使用了。   \n\n直到出现 Agent pid XXXX 这样的提示之后，输入：    \n`ssh‐add ~/.ssh/id_rsa\n`  \n\n这样，就成功的在本地生成了一个可用的ssh key。  \n#### 四、将ssh Key添加到Github中   \n\n下面将这个 key 添加到 github 网站。 \n打开https://github.com/settings/ssh,  点击 Add ssh Key ，复制 id_rsa.pub(或者是你自己重命名的公钥名称) 中的所有内容到 Key 框中，在 Title 框中输入方便自己记忆的名字（建议输入能让自己明白是哪台电脑的名字，方便以后管理）。 \n当网页显示添加成功后，就已经完成了全部的操作。\n下面进行一些测试，同样是打开 Git Bash 或 cmder，输入： \n`ssh ‐T git@github.com\n`\n bash 或 cmder 中会显示如下字样：\n`The authenticity of host 'github.com (207.97.227.239)' can't be established.\nRSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\nAre you sure you want to continue connecting (yes/no)?  \n`  \n\n输入 yes 之后，计算机会自动将 github.com 列入已知的 host，然后会出现如下提示：   \n\n`Hi username! You've successfully authenticated, but GitHub does not\nprovide shell access.    \n`  \n\n如果成功看见，说明你已经配置好了。 \n如果出现任何错误提示，请仔细检查自己的操作。  \n\n*另外* 由于 ssh 配置文件的不匹配，导致的 Permission denied (publickey)及其解决方法：一定要保持新生成的密匙文件的名字同 “ssh_config” 中 “IdentityFile” 字段的值一致即可，其中`ssh_config`文件在`{Git的安装路径}\\etc\\ssh\\ssh_config`路径。\n例如：  \n```\nHost github.com\n\tUser git\n\tStrictHostKeyChecking no\n\tIdentityFile ~/.ssh/{你的rsa私钥的名称}\n\tIdentitiesOnly yes\n```\n","cover":"","link":"./post/2016/07/09/hexo-ssh-key.html","preview":"\u003cp\u003e以下方法适合于 Windows 用户，如果是 Linux或者 Mac 用户可以直接用终端的命令进行操作。\u003c/p\u003e\n","title":"使用 Github ssh key 部署 Hexo 博客"},{"content":"\n\n一、要使用搜索，必须先生成博客索引数据，Hexo  可以通过下面的这个插件生成：\n```\nnpm install hexo-generator-search --save\n```\n二、只需要在 Hexo 站点 _config.yml 中添加如下配置即可：\n```\nsearch:\n  path: search.xml\n  field: post\n```\n- **path** - file path. Default is `search.xml` .\n- **field** - the search scope you want to search, you can chose:\n  * **post** (Default) - will only covers all the posts of your blog.\n  * **page** - will only covers all the pages of your blog.\n  * **all** - will covers all the posts and pages of your blog.\n\n\n   更多配置说明可到插件页面查看：[hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search)  \n\n三、然后在 themes/next/layout/_partials/search 目录下修改 localsearch.swig 文件。  \n  原始文件内容如下：   \n\n```javascript\n \u003cscript type=\"text/javascript\"\u003e\n     var search_path = \"\u003c%= config.search.path %\u003e\";\n     if (search_path.length == 0) {\n     \tsearch_path = \"search.xml\";\n     }\n     var path = \"\u003c%= config.root %\u003e\" + search_path;\n     searchFunc(path, 'local-search-input', 'local-search-result');\n \u003c/script\u003e\n```\n\n 修改后的文件内容为:  \n\n```html\n\u003cdiv class=\"popup\"\u003e\n \u003cspan class=\"search-icon fa fa-search\"\u003e\u003c/span\u003e\n \u003cinput type=\"text\" id=\"local-search-input\" placeholder=\"search my blog...\"\u003e\n \u003cdiv id=\"local-search-result\"\u003e\u003c/div\u003e\n \u003cspan class=\"popup-btn-close\"\u003eclose\u003c/span\u003e\n\u003c/div\u003e\n```\n\n其他的地方都不需要改，这样 Hexo 本地站内搜索就完成了。(P.S. 此处 **hexo-theme-next** 的版本为5.0.0，以后较新的 Next 版本里 localsearch.swig 原始文件内容可能会和以上列的内容不一致，**此处不必再改** 。)  \n\n\n\n四、补充\n\n看到这，我先说说一下静态站关于实现站内搜索的方式，它有两种方式：一是本地建立索引，二是采用第三方线上服务。在 next 主题所在目录下的 `/layout/_partials/search` 目录中分别有三个文件：`localsearch.swig`、`swiftype.swig`、`tinysou.swig` ，其中 [tinysou](https://github.com/tinysou/) 这个项目已经很长时间没在维护了，不推荐使用。剩下的两个就是本地搜索和第三方线上服务。然而 [swiftype](https://swiftype.com) 不再提供免费账户(老用户还可以免费用)了，那剩下的就只有 localsearch 这条路了。\n\n在目前最新 5.13 版本中 [hexo-theme-next search 目录](https://github.com/iissnan/hexo-theme-next/tree/master/layout/_partials/search) 中`localsearch.swig`已经更新为：\n\n```html\n\u003cdiv class=\"popup search-popup local-search-popup\"\u003e\n  \u003cdiv class=\"local-search-header clearfix\"\u003e\n    \u003cspan class=\"search-icon\"\u003e\n      \u003ci class=\"fa fa-search\"\u003e\u003c/i\u003e\n    \u003c/span\u003e\n    \u003cspan class=\"popup-btn-close\"\u003e\n      \u003ci class=\"fa fa-times-circle\"\u003e\u003c/i\u003e\n    \u003c/span\u003e\n    \u003cdiv class=\"local-search-input-wrapper\"\u003e\n      \u003cinput autocomplete=\"off\"\n             placeholder=\"{{ __('search.placeholder') }}\" spellcheck=\"false\"\n             type=\"text\" id=\"local-search-input\"\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv id=\"local-search-result\"\u003e\u003c/div\u003e\n\u003c/div\u003e\n```\n\n搜索部分的网页样式已经修复了，因此，`localsearch.swig`不必再改。剩下关键的部分就是 [hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search)  的配置了。  \n\n\n\n五、效果演示  \n\n后来由于我，博客主题不再使用 [Next](https://github.com/iissnan/hexo-theme-next) ，所以上面的效果展示在原来的博客上 [THE TIME MACHINE](https://www.codeomega.ga/)。如果链接打不开，直接看下面的 GIF 动画效果演示：\n\n![hexo-theme-next 本地搜索效果演示](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/hexo-localsearch.gif)","cover":"","link":"./post/2016/07/08/hexo-localsearch.html","preview":"\u003cp\u003e一、要使用搜索，必须先生成博客索引数据，Hexo  可以通过下面的这个插件生成\u003c/p\u003e\n","title":"实现 Hexo next 主题博客本地站内搜索"}]