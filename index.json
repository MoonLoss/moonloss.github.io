[{"content":"\n昨天在自己的 vps (运行 debian8 64bits)上，使用 [caddy](https://caddyserver.com/)  作为 web 服务器。现将配置流程记录一下。  \n\n### 安装 caddy  \n\ncaddy ——『 the http/2 web server with automatic https 』，使用 go 编写。  \n\n![caddy-server.png](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/caddy-server.png)  \n在本地下载 caddy ，目录大致如下：  \n```\n.\n|-- caddy\n|-- init\n|   |-- readme.md\n|   |-- freebsd\n|   |   `-- caddy\n|   |-- linux-systemd\n|   |   |-- readme.md\n|   |   `-- caddy.service\n|   |-- linux-sysvinit\n|   |   |-- readme.md\n|   |   `-- caddy\n|   `-- linux-upstart\n|       |-- readme.md\n|       `-- caddy.conf\n```\n然后用`scp`命令或者用 [winscp](https://winscp.net) (一个利用 `sftp` 协议并且基于 `putty`的 windows 上的图形化软件)来上传。  \n给 `caddy` 赋予可执行权限后，再复制到`/usr/local/bin`：     \n\n```\nchmod +x caddy \nmv caddy /usr/local/bin/\n```\n### 配置 caddy  \n\ncaddy 的配置文件为`caddyfile`(在此之前需要配置好网站`example.com`(你的域名)的权威 dns 的 a 记录或者 aaaa 记录)：  \n```\nexample.com {\n  gzip\n  root /var/www/html/\n}\n```\n配置完成后，运行：\n```\n/usr/local/bin/caddy --conf=/etc/caddy/caddyfile\n```\n这样 web 服务器就运行其来了。接下来后介绍配置`systemd`运行 caddy。     \n如果没有注册过 ssl 证书，此时会要你输入的邮箱下载[ let’s encrypt](https://letsencrypt.org) 的证书了，此时要保证域名的 dns 已经配置好了。\n\n### 配置 systemd  \n\n使用`systemd`注册`caddy`为一个服务，开机自动运行。\n如上文我们所看到的那样，`caddy`的下载压缩文件中包含一个`init`文件夹，其中包含`systemd`，`upstart`，`sysvinit`等各种的启动脚本。  \n\n`systemd` 配置文件`caddy.service`：  \n```\n[unit]\ndescription=caddy http/2 web server\nafter=syslog.target\nafter=network.target\n\n[service]\nuser=root\ngroup=root\nlimitnofile=64000\nexecstart=/usr/local/bin/caddy --conf=/path/to/caddyfile\nrestart=on-failure\n\n[install]\nwantedby=multi-user.target\n```\n配置文件写好后，运行：  \n```shell\ncd init/linux-systemd/\ncp caddy.service /etc/systemd/system/\nsystemctl start caddy  #启动\n```\n\n还可查看启动状态：\n```shell\nsystemctl status caddy #查看启动状态\n```\n\n### 如何安装插件  \n\n对于如何安装插件，可参考  \n[无闻的博客](https://wuwen.org/2015/11/13/caddy-in-action.html)    \n[caddy doc](https://caddyserver.com/docs/faq)  ","cover":"","link":"./post/2016/11/13/caddy-server.html","preview":"\u003cp\u003e昨天在自己的 vps (运行 debian 8 64bits )上，使用  caddy 作为 web 服务器。现将配置流程记录一下。\u003c/p\u003e\n","title":" debian 上搭建 caddy server "},{"content":"\n\n尝试了一下，windows 下 codeblocks 利用 mingw 编译器编写动态链接库，结果虽然 dll 是生成了，但过程还是不太满意。因为 dll 是 windows 下才用到的，似乎用 gnu 的编译器不太合适，最终还是改用 vs2015 (虽然它很‘臃肿’)。然后，我就尝试在 linux 上编写`.so`(shared object, 共享库。和 dll 类似)文件。    \n在 linux 上，我尝试了 jetbrains 家的 clion ，它的代码提示，确实比 codeblock 好，这点值得肯定。而且在 linux 上的构建速度比在 windows 上快(相同硬件条件下) 。虽然 clion 是收费软件，但是有学生优惠。我用 edu 邮箱申请一年期的免费使用权，到期之后还可以用 edu 邮箱再次验证使用。在能力范围之内，能不用破解软件，就不用破解软件。要**尊重同行的劳动**。 \n\n回到正题，静态库、动态库在不同系统下的对应关系：  \nlinux： `.a` (archive libraries) 和 `.so`(shared object)  ;     \nwindows： `.lib` 和 `.dll`(dynamic-link library)\n\n### 先编写一个库试试  \n首先用 clion 新建一个项目 \"hello\"，main.cpp 的内容为：  \n\n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\nvoid hi()\n{\n    cout \u003c\u003c \"hello,nihao\" \u003c\u003c endl;\n}\nint add(int a,int b)\n{\n    return a + b;\n}\n```\n\ncmakelists.txt (学名：组态档)的内容：  \n```\ncmake_minimum_required(version 3.6)\nproject(hello)\n\nset(cmake_cxx_flags \"${cmake_cxx_flags} -std=c++11\")\n\nset(source_files main.cpp)\n#动态库\nadd_library(hello shared ${source_files})\n#静态库\nadd_library(hell ${source_files})\n```\n编译生成`libhello.so`。 可用`nm -c libhello.so`来查看符号表：  \n```\n0000000000201040 b __bss_start\n0000000000201040 b completed.7585\n                 u __cxa_atexit@@glibc_2.2.5\n                 w __cxa_finalize@@glibc_2.2.5\n0000000000000840 t deregister_tm_clones\n00000000000008d0 t __do_global_dtors_aux\n0000000000200dd0 t __do_global_dtors_aux_fini_array_entry\n0000000000201038 d __dso_handle\n0000000000200de0 d _dynamic\n0000000000201040 d _edata\n0000000000201048 b _end\n00000000000009e4 t _fini\n0000000000000910 t frame_dummy\n0000000000200dc0 t __frame_dummy_init_array_entry\n0000000000000af0 r __frame_end__\n0000000000201000 d _global_offset_table_\n00000000000009cf t _global__sub_i_main.cpp\n                 w __gmon_start__\n00000000000009fc r __gnu_eh_frame_hdr\n00000000000007b8 t _init\n                 w _itm_deregistertmclonetable\n                 w _itm_registertmclonetable\n0000000000200dd8 d __jcr_end__\n0000000000200dd8 d __jcr_list__\n                 w _jv_registerclasses\n0000000000000880 t register_tm_clones\n0000000000201040 d __tmc_end__\n0000000000000940 t hi()\n0000000000000972 t add(int, int)\n0000000000000986 t __static_initialization_and_destruction_0(int, int)\n                 u std::ostream::operator\u003c\u003c(std::ostream\u0026 (*)(std::ostream\u0026))@@glibcxx_3.4\n                 u std::ios_base::init::init()@@glibcxx_3.4\n                 u std::ios_base::init::~init()@@glibcxx_3.4\n                 u std::cout@@glibcxx_3.4\n                 u std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026 std::endl\u003cchar, std::char_traits\u003cchar\u003e \u003e(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026)@@glibcxx_3.4\n00000000000009ed r std::piecewise_construct\n0000000000201041 b std::__ioinit\n                 u std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026 std::operator\u003c\u003c \u003cstd::char_traits\u003cchar\u003e \u003e(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026, char const*)@@glibcxx_3.4\n```\n\n\n### 动态库显式调用(运行时装入)  \n新建一个项目 \"openso\"，以下是`main.cpp`的内容：  \n```c++\n#include \u003ciostream\u003e\n#include \"dlfcn.h\"//显式调用的头文件\n\nusing namespace std;\n\nint main() {\n\n    cout \u003c\u003c \"c++ dlopen\" \u003c\u003c endl;\n\n    // 打开库文件\n    cout \u003c\u003c \"opening libhello.so...\" \u003c\u003c endl;\n    //动态库 libhello.so 的绝对路径\n    void *handle = dlopen(\"/home/yang/desktop/openso/lib/libhello.so\", rtld_lazy);\n\n    if (!handle) {\n        cerr \u003c\u003c \"cannot open library: \" \u003c\u003c dlerror() \u003c\u003c endl;\n        return 1;\n    }\n\n    // 加载符号表\n    cout \u003c\u003c \"loading symbol hi...\" \u003c\u003c endl;\n    typedef void (*hi_t)();\n\n    // 错误\n    dlerror();\n    hi_t hi = (hi_t) dlsym(handle, \"hi\");\n    const char *dlsym_error = dlerror();\n    if (dlsym_error) {\n        cerr \u003c\u003c \"cannot load symbol 'hi': \" \u003c\u003c dlsym_error \u003c\u003c endl;\n        dlclose(handle);\n        return 1;\n    }\n\n    cout \u003c\u003c \"calling hi()...\" \u003c\u003c endl;\n    hi();\n\n    // 加载符号表\n    cout \u003c\u003c \"loading symbol add...\" \u003c\u003c endl;\n    typedef int (*add_t)(int, int);\n\n    // 错误\n    dlerror();\n    add_t add = (add_t) dlsym(handle, \"add\");\n    if (dlsym_error) {\n        cerr \u003c\u003c \"cannot load symbol 'add': \" \u003c\u003c dlsym_error \u003c\u003c endl;\n\n        dlclose(handle);\n        return 1;\n    }\n\n    cout \u003c\u003c \"calling the add()...\"\u003c\u003c endl;\n    cout \u003c\u003c add(2, 3) \u003c\u003c \" is the result\"\u003c\u003c endl;\n\n    // 关闭库文件\n    cout \u003c\u003c \"closing library...\"\u003c\u003c endl;\n    dlclose(handle);\n}\n```\n\ncmakelists.txt 的内容： \n```\ncmake_minimum_required(version 3.6)\nproject(openso)\n\nset(cmake_cxx_flags \"${cmake_cxx_flags} -std=c++11\")\nset(source_files main.cpp)\nadd_executable(openso ${source_files})\ntarget_link_libraries(openso ${cmake_dl_libs})\n```\n编译，也可以在项目的根目录下执行`g++ -o main main.cpp -ldl`。\n\n程序运行结果如下：  \n\n```\nc++ dlopen\nopening libhello.so...\nloading symbol hi...\ncalling hi()...\nhello,nihao\nloading symbol add...\ncalling the add()...\n5 is the result\nclosing library...\n```\n\n\n\n### 动态库隐式调用(编译时装入)  \n新建一个项目 \"hideso\"，以下是`main.cpp`的内容：  \n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\nvoid hi();\nint  add(int,int);\n\nint main(int argc,char *argv[])\n{\n    hi();\n    cout \u003c\u003c endl;\n    cout \u003c\u003c add(13,12) \u003c\u003c endl;\n    return 0;\n}  \n```\n\ncmakelists.txt 的内容：  \n```   \ncmake_minimum_required(version 3.6)\nproject(hideso)\n\nset(cmake_cxx_flags \"${cmake_cxx_flags} -std=c++11\")\n\nset(source_files main.cpp)\nadd_executable(hideso ${source_files})\ntarget_link_libraries(hideso /home/yang/desktop/hideso/libhello.so)\n```\n编译，也可以在项目的根目录下执行` g++ -o main main.cpp ./libhello.so`。\n\n在执行隐式链接的程序之前，需要设置 ld_library_path 环境变量，或者把前面生成的 libhello.so 复制到系统路径下，否则报错：  \n```\nerror while loading shared libraries: libhello.so: cannot open shared object file: no such file or directory\n```\n运行可在项目根目录下执行：  \n```\nexport ld_library_path=.\n./main\n```\n还可直接用`ldd`命令查看其所隐式调用的库。  \n\n\n对于 c 语言编译的库，c++ 调用时需要这么做(保证c/c++ 兼容性，注意`cplusplus`前面是两个'_')：    \n\n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\n#ifdef __cplusplus\nextern \"c\"\n{\n#endif\n\tvoid hi();\n\tint add(int,int);\n#ifdef __cplusplus\n}\n#endif\n\nint main(int argc,char *argv[])\n{\n    hi();\n    cout \u003c\u003c endl;\n    cout \u003c\u003c add(12,13) \u003c\u003c endl;\n    return 0;\n}\n```\n当然了，c++ 编写的库，c 是无法直接调用的。那如果 c 想调用 c++的库， 应该怎么做呢？请接着往下看。\n\n### c 调用 c++ 库\n\nc 调用 c++ 的库，一般不能直接调用，需要将 c++ 库转换成 c 接口(也就是要用`extern \"c\"`)输出，才可以用 c 来调用，这里举个例子(比如 c++ 中的“类”)：  \n\n```c++\n#include \u003ciostream\u003e\n\n#ifdef __cplusplus\nextern \"c\"\n{\n#endif\n    int here();\n#ifdef __cplusplus\n}\n#endif\n\nusing namespace std;\n\nclass hi {\n    public:\n    int hello() {\n        cout \u003c\u003c \"here() is called\" \u003c\u003c endl;\n    }\n};\n\nint here() {\n    hi hh;\n    hh.hello();\n    return 0;\n}\n\n```\n\ncmakelists.txt 内容不再赘述。  \n\n接下来只简单说一下它的显示调用：  \n\n```c\n#include \u003cstdio.h\u003e\n#include \u003cdlfcn.h\u003e\n\nint main()\n{\n    int (*dlfunc)();\n    void *handle;  //定义一个句柄\n    handle = dlopen(\"./libcppso.so\", rtld_lazy);//获得库句柄\n    dlfunc = dlsym(handle, \"here\"); //获得函数入口\n    (*dlfunc)();\n    dlclose(handle); \n\n    return 0;\n}\n```\n\n运行输出如下：  \n\n```\nhere() is called\n```\n\n\n\n### cmake 相关:       \n\u003e [cmake wiki](https://cmake.org/wiki/cmake)  \n\u003e [cmake 常用命令和变量](http://elloop.github.io/tools/2016-04-10/learning-cmake-2-commands)  \n\u003e [cmake使用进阶](http://linghutf.github.io/2016/06/16/cmake/)    \n\u003e [cmake 简要教程--相关工具对比](http://reyoung.me/post/cmake_talk_1/)    \n\n### make 相关\n\nmakefile + make 为 unix-like 环境下的项目管理工具(抽象程度低)。对于如何使用 makefile 编译动态库和静态库，可参考这篇文章：[linux编译动态库和静态库的makefile示例](http://blog.csdn.net/shaoxiaohu1/article/details/46943417) 。需要说明一点：**cmake 也是根据 cmakelists.txt 文件去生成 makefile 的** (可以跨平台生成对应平台能用的 makefile) 。而且 cmake 是抽象层次更高的项目管理工具。当你需要编译一个大项目，而大项目各文件的依赖关系复杂，makefile 并不好写，这时使用 cmake 则很方便。\n\n### 链接、装载与库相关\n\n可以看看《程序员的自我修养——链接、装载与库》这本书。","cover":"","link":"./post/2016/11/05/linux-shared-object.html","preview":"\u003cp\u003e尝试了一下，windows 下 codeblocks 利用 mingw 编译器编写动态链接库，结果虽然 dll 是生成了，但过程还是不太满意。因为 dll 是 windows 下才用到的，似乎用 gnu 的编译器不太合适，最终还是改用 vs2015 (虽然它很‘臃肿’)。\u003c/p\u003e\n","title":"linux 下用 clion 编写及调用共享库的实践"},{"content":"\n『聰明的輸入法懂我心意』，正如 [rime](http://rime.im/) 官网所说得那样。windows 平台下叫『小狼毫』(英文名:weasel) ,linux 平台下叫『中州韻』(英文名:rime)，mac 平台叫『鼠鬚管』(英文名:squirrel)，当然也有 android 版的，叫『同文 』。我个人觉得是输入法中做得非常独特的一个，做得非常好，用着非常舒服。  \n\n下面我先来说说 linux 下的安装：  \n首先我 linux 上的输入法框架是`fctix`,所以我安装`fctix-rime`。(注意，最好不要在 linux 上安装多个输入法框架)只需一条命令(debian 系列及其衍生版)就可以了：  \n```\nsudo apt install fcitx-rime\n```  \n然后注销重新登录就可以尽情使用了。  `fcitx-rime`的更多内容，可参阅[fcitx-rime](https://github.com/fcitx/fcitx-rime)。  \n对于是 ibus 框架的，请参考这里[rimewithibus](https://github.com/rime/home/wiki/rimewithibus)。  \n\n再提一下 windows 下的安装：  \n如果是 windows7 及以下，则直接可以在官网下载使用。若是 windows8及以上，包括 windows10，很不幸，其兼容性不好，卡 modern 界面。但是有解决方案，目前其中最好的方案是 [prime](https://github.com/osfans/prime) ,这其中还带来了 emoji 输入。  \n![prime.png](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/prime.png)  \n\n至于如何去配置，就去看 [wiki](https://github.com/rime/home/wiki/userguide) 好了。","cover":"","link":"./post/2016/11/01/rime.html","preview":"\u003cp\u003e『聰明的輸入法懂我心意』，正如 rime 官网所说得那样。\u003c/p\u003e\n","title":"谈谈 rime "},{"content":"\n今年1月份就想写个关于如何用 [refind](http://www.rodsbooks.com/refind/) 管理多系统引导，但是一直拖到现在。回到正题，refind 相当于一个菜单，开机进入这个菜单，选择菜单上的某个系统进入就可以了。当然它的魅力不仅在于此，还在于如果此时你挂载一个 u 盘或者移动硬盘,里面装了你喜欢的操作系统，硬件识别之后 ，refind 也会在菜单上显示出来。  \n![图片来自于贴吧，非默认主题](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/refind-interface.jpg)  \n   \n对于默认主题，配置文件`refind.conf`文件可以这样写：  \n```\n#设置默认时间5s，时间到后进入默认操作系统。\n#0表示一直等待选择\ntimeout 5\n\nscan_driver_dirs efi/refind/drivers_x64\n\nscanfor manual,external,optical\n\ndefault_selection windows 10\n\nmenuentry \"windows 10\" {\n\ticon \\efi\\refind\\icons\\os_win10.png\n    loader \\efi\\microsoft\\boot\\bootmgfw.efi\n}\t\n\nmenuentry \"linux mint\"{\n\ticon /efi/refind/icons/os_linuxmint.png\n    loader /efi/ubuntu/shimx64.efi\n}\n```\n注：`shimx64.efi`这个引导文件是已经加过签名的，而`grubx64.efi`则没有。因此，使用`shimx64.efi`后是可以开启 bios 的`secure boot`的 。**若开启了`secure boot`，还需在 bios 中加入 refind 的证书，是这个两个文件`refind.cer`和`refind.crt` **。\n\nwindows 用户可以使用 diskgenius 和 bootice 这两个工具进行相关的设置。\n\n","cover":"","link":"./post/2016/10/28/refind.html","preview":"\u003cp\u003erefind 相当于一个菜单，开机进入这个菜单，选择菜单上的某个系统进入就可以了。\u003c/p\u003e\n","title":"用 refind 管理多系统引导"},{"content":"\n\n教大家用 hugo 建个人博客的文章太多了，这次我要介绍的是用 gitlab-cl 自动部署( 持续集成 ) hugo blog 到 github pages 上 (p.s. 当然前提是你必须有 gitlab 账号哦 )，其核心就是一个配置文件`.gitlab-ci.yml`:  \n```\n# alpine linux \n#其包管理是 apk\nimage: alpine:3.4\n\nbefore_script:\n  - apk update \n  - apk add openssl \u0026\u0026 apk add git \u0026\u0026 apk add nodejs\n  - npm install\n  - wget https://github.com/spf13/hugo/releases/download/v0.16/hugo_0.16_linux-64bit.tgz\n  - echo \"37ee91ab3469afbf7602a091d466dfa5  hugo_0.16_linux-64bit.tgz\" | md5sum -c\n  - tar xf hugo_0.16_linux-64bit.tgz \u0026\u0026 cp ./hugo /usr/bin\n  - hugo version\n\npages:\n  cache:\n    paths:\n    - node_modules/\n\n  script:\n  - git clone https://\u003cyour personal access tokens\u003e@github.com/\u003cyour user name\u003e/\u003cyour repository name\u003e public\n  - npm run build\n  - cd ./public\n  - git config user.name \"\u003cyour user name\u003e\"\n  - git config user.email \"\u003cyour email\u003e\"\n  - git config --global push.default simple\n  - git add .\n  - git commit -m \"update site\"\n  - git push --set-upstream \"https://\u003cyour personal access tokens\u003e@github.com/\u003cyour user name\u003e/\u003cyour repository name\u003e\"\n  artifacts:\n    paths:\n    - public\n  only:\n  - master\n```  \n我这里使用的是 hugo 的 1.6 版本，当然你也可以安装当前最新的 1.7 版本。  \n由于我使用了`gulp`压缩 html 和 js 文件，所以需要安装`nodejs`。下面是`gulp`的配置文件`gulpfile.babel.js`的内容：  \n```\nimport gulp from 'gulp'\nimport htmlmin from 'gulp-htmlmin'\nimport uglify from 'gulp-uglify'\nimport runsequence from 'run-sequence'\nimport shell from 'gulp-shell'\n\ngulp.task('hugo-build', shell.task(['hugo']))\n\ngulp.task('minify-html', () =\u003e {\n  return gulp.src('public/**/*.html')\n    .pipe(htmlmin({\n      collapsewhitespace: true,\n      minifycss: true,\n      minifyjs: true,\n      removecomments: true,\n      useshortdoctype: true,\n    }))\n    .pipe(gulp.dest('./public'))\n})\n\ngulp.task('minify-js', () =\u003e {\n    return gulp.src('./public/**/*.js')\n        .pipe(uglify())\n        .pipe(gulp.dest('./public'));\n});\n\ngulp.task('build', ['hugo-build'], (callback) =\u003e {\n  runsequence('minify-html','minify-js', callback)\n})\n```\n这里用`gulp-shell`这个包，执行`hugo`这个命令。  \npackage.json的内容:\n```\n{\n  \"private\": true,\n  \"scripts\": {\n    \"build\": \"gulp build\"\n  },\n  \"devdependencies\": {\n    \"babel-preset-es2015\": \"^6.5.0\",\n    \"babel-register\": \"^6.5.2\",\n    \"gulp\": \"^3.9.1\",\n    \"gulp-cli\": \"^1.2.1\",\n    \"gulp-htmlmin\": \"^1.3.0\",\n    \"gulp-uglify\": \"^2.0.0\",\n    \"gulp-shell\": \"^0.5.2\",\n    \"run-sequence\": \"^1.1.5\"\n  },\n  \"babel\": {\n    \"presets\": [\n      \"es2015\"\n    ]\n  }\n}\n```  \n由于`gulpfile.babel.js`采用`ecmascript 6`标准，使用了最新的 javascript 语法，需要用`babeljs`将其语法转化。  \n这些做完之后就可以在`.gitlab-ci.yml`中用`npm run build`部署你的 blog 了。","cover":"","link":"./post/2016/10/17/gitlab-cl.html","preview":"\u003cp\u003e教大家用 hugo 建个人博客的文章太多了，这次我要介绍的是用 gitlab-cl 自动部署( 持续集成 ) hugo blog 到 github pages 上\u003c/p\u003e\n","title":"通过 gitlab-cl 将 hugo blog 自动部署至 github "},{"content":"\n\n  近日，想在 windows 系统下编译 linux-0.11 内核。 于是就在 virtualbox 中安装了 [alpine linux](http://alpinelinux.org/) 3.4 。  \n  其中 virtualbox 下的网络配置如下：  \n使用2块网卡，第一块设置为`host-only`方式：  \n![vbox-network-1.png](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/vbox-network-1.png)  \n  第二块设置为`nat`方式：\n![vbox-network-2.png](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/vbox-network-2.png)  \n  其中，virtualbox host-only ethernet adapter 的配置如下：  \n![vbox-hostonly.png](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/vbox-hostonly.png)   \n  \n![vbox-hostonly-ipv4.png](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/vbox-hostonly-ipv4.png)  \n  其中, dns 服务器地址设置和本地上网的设置相同。   ip 地址是自动生成，也可手动修改。这里我使用的是阿里的公共 dns 。  \n  然后登陆 alpine linux ，查看 mac 地址是否和在 virtualbox 中网络设置中的 mac 地址一样。\n![alpine-network.png](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/alpine-network.png)  \n  这样主机和虚拟机就可以互 ping ，主机还可通过   ssh 连接虚拟机。例如：`ssh root@192.168.56.101`   (ps. 我用的是 [cmder](http://cmder.net/) 上的 ssh 工具)。  \n\n\u003e* 推荐： 在windows上可以用 [ssh secure shell client](http://www.wm.edu/offices/it/services/software/licensedsoftware/webeditingsftp/sshsecureshell/index.php) 这个工具替代`scp`命令在主机和虚拟机之间传输文件。  \n   ![sshsecureshellclient.png](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/sshsecureshellclient.png)    \n   \n      \n  到这儿，都是些准备工作，接下来才是本文要说的东西。  \n由于 linux 0.11 (原版)内核编译需要 gcc3.4.6  ,而这个 gcc 版本太老了。于是就出现了 linux 0.11-gcc4 这个版本(网上可以搜到),可以用 gcc4.x 去编译。在我的 linux mint 18 上，修改了几个错误之后，用自带的 gcc5.4.0 编译成功了（此处为我修改的[源码](https://cdn.rawgit.com/qanno/qanno.github.io/master/downloads/linux-gcc5.4.0.zip)，如果还有错误编译不通过，请参考[这篇文章](http://www.voidcn.com/blog/hjq842382134/article/p-5955492.html)），我不甘心，我想用更高的 gcc 版本去完成这件事。在 gihub 上 search   了一番，发现了这个：[linux-0.11](https://github.com/yuanxinyu/linux-0.11)，这个修改版我终于在 alpine linux 上编译成功了（如果遇到： \"make: execvp: /tools/build.sh permission denied .\" 请修改build.sh的权限。）。\n  最后，用 [bochs](http://bochs.sourceforge.net) 模拟启动成功了。  \n  ![bochs-linux0.11.png](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/bochs-linux0.11.png)\n其中 bochs 的 bxrc 文件：  \n```\n#bios映像文件和vga bios映像文件\n#xxx为bochs的安装盘\nromimage: file=xxx:\\bochs-2.6.8\\bios-bochs-latest\n#运行内存\nmegs: 64\nvgaromimage: file=xxx:\\bochs-2.6.8\\vgabios-lgpl-latest\n#这个是启动软盘\nfloppya: 1_44=c:\\users\\xxxx\\desktop\\image,status=inserted\nata0-master: type=disk, path=\"c:\\users\\xxxx\\desktop\\linux_0_11-master\\hdc-0.11.img\", mode=flat, cylinders=204, heads=16, spt=38\n#确定启动方式\nboot: c\nlog: c:\\users\\xxxx\\desktop\\bochsout.txt\ncpu: count=1, ips=1000000\n```\n","cover":"","link":"./post/2016/10/10/compile-linux-kernal.html","preview":"\u003cp\u003e近日，想在 windows 系统下编译 linux-0.11 内核。 于是就在 virtualbox 中安装了 alpine linux 3.4\u003c/p\u003e\n","title":"在 alpine linux 上编译 linux0.11 内核"},{"content":"\n\n　　用`python`实现了一个带参数的命令行将图片转换成`progressive encoding`(渐进式) jpeg 格式。  \n　　这里先贴出代码：  \n```python\n#! python3\nimport platform, sys, os\nimport getopt\nfrom pil import image ,imagefile\n\ndef iswindows():\n    return 'windows' in platform.system()\n \ndef islinux():\n    return 'linux' in platform.system()\n\ndef usage():\n    print (\"-h: this message.\")\n    print (\"-i [file]: the path of the target image file. \")\n    print (\"-o [filepath]: the path of the output. \")\n    print (\"examples:\")\n    print (\"$py tojpeg.py -i /home/test.jpg - o /home\")\n\ndef info():\n    print (\"**************************************************\")\n    print (\"**|''''''''''''''''''''''''''''''''''''''''''''|**\")\n    print (\"**|convert images to progressive encoding jpeg |**\")\n    print (\"**|version: 1 beta                             |**\")\n    print (\"**|by: zetao yang                              |**\")\n    print (\"**|email: yangzetao2015[@] outlook             |**\")\n    print (\"**|https://zetaoyang.github.io                 |**\")\n    print (\"**|-                                           |**\")\n    print (\"**|usage: $tojpeg -h                           |**\")\n    print (\"**|                                            |**\")\n    print (\"**|,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,|**\")\n    print (\"**************************************************\")\n    print (\"\")\n\nif(iswindows()):\n   os.system(\"cls\")\nif(islinux()):\n   os.system(\"clear\")\n\ndef main():\n    info()\n    try:\n        #使用sys.argv[1:] 过滤掉第一个参数\n        #（它是执行脚本的名字，不应算作参数的一部分）\n        opts,args = getopt.getopt(sys.argv[1:],\"hi:o:\", [\"help\",\"input=\" ,\"output=\"])\n    except getopt.getopterror as err:\n        print (err)\n        sys.exit(2)\n\n    if not opts and not args:\n        usage()\n        sys.exit()\n\n    for opt, arg in opts:\n        if opt in (\"-h\",\"--help\"):\n            usage()\n            sys.exit()\n        elif opt in (\"-i\",\"--input\"):\n            input_file = arg\n        elif opt in (\"-o\",\"--output\"):\n            output_path = arg\n        else:\n            assert false, \"unhandled option\"\n\n    try:\n        img = image.open(input_file)\n        destination = output_path + \"/output.jpeg\"\n        try:\n            img.save(destination,\"jpeg\",quality=80,optimize=true,progressive=true)\n            print(\"conversion is ok.\")\n        except ioerror:\n            imagefile.maxblock = img.size[0]*img.size[1]\n            img.save(destination,\"jpeg\",quality=80,optimize=true,progressive=true)\n    except keyboardinterrupt:\n        print (\"\\nwell i hope you had a good time.\")\n        \nif __name__ == \"__main__\":\n    main()\n```  \n   最后可以用 [pyinstaller](https://github.com/pyinstaller/pyinstaller) 打包分发了。\n","cover":"","link":"./post/2016/10/09/progressive-encoding-jpeg.html","preview":"\u003cp\u003eusing python to generate progressive encoding jpeg\u003c/p\u003e\n","title":"生成渐进式 jpeg"},{"content":"\n\n　　 前几天，在 v2ex 看见有人用 github api 基于python实现了一个图床。于是我决定用 nodejs 也实现一个类似功能。首先我看有没现成的第三方库，在 [libraries | github developer guide](https://developer.github.com/libraries/) 我发现有五个跟 javascript 相关的库：  \n\u003cdiv align=center\u003e\n![github-api-js.jpg](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/github-api-js.png)  \n\u003c/div\u003e\n经调研发现 [github.js wrapper around the github api](https://github.com/michael/github) 比较好入手，基本将 github api 全都实现了，并且封装了自己的接口，但是缺点还是有的，文档写的不太详细。然后就开始看它的文档，其中 repository 的 writefile() 方法就是上传文件的函数。  \n其中 writefile():  \n\u003cdiv align=center\u003e\n![github-api-writefile-2.3.0.png](https://cdn.rawgit.com/qanno/qanno.github.io/master/images/github-api-writefile-2.3.0.png)  \n\u003c/div\u003e  \n　　 先在这里贴出代码( ecmascript 2015 标准)： \n```javascript\n//导入github-api\nvar github = require(\"github-api\")\nvar fs = require(\"fs\")\n\nconst gh = new github({\n\ttoken: '\u003cyour personal token\u003e'//这里采用token认证\n})\n\nvar branch = '\u003cbranch_name\u003e'//eg. master\nvar ufilepath = '\u003crepo_path\u003e'//eg. images/\n//{master}/xxx.jpg\nvar ufilename = '\u003cfile_name\u003e'//eg. xxx.jpg\nvar commit = 'here i am'\nvar user = '\u003cuser name\u003e'//用户名\nvar repo = '\u003crepository name\u003e'//仓库名\n\nconst re = gh.getrepo(user,repo)\n\n//同步读取文件\nvar imageblob = fs.readfilesync('\u003cfilepath\u003e')\n//base64编码\nvar imageb64 = imageblob.tostring('base64')\n//ascii编码\n//utf8编码也可以，只不过有些浪费。\nvar data = imageb64.tostring('ascii')\n\nvar options = {\n    //author:{},\n    //commiter:{},\n    encode: false\n}\n\nre.writefile(branch, ufilepath + ufilename, data , commit,options, (error,result,request)=\u003e{\n    if (error===null) {\tconsole.log(`https://cdn.rawgit.com/${user}/${repo}/${branch}/${ufilepath}${ufilename}`)\n\t }\n})\n\n```  \n　　 这其中的关键就是编码问题， github contents api 要求 content 是 base64 编码。 \n\n\n\t","cover":"","link":"./post/2016/10/08/github-api.html","preview":"\u003cp\u003e前几天，在 v2ex 看见有人用 github api 基于python实现了一个图床。于是我决定用 nodejs 也实现一个类似功能。\u003c/p\u003e\n","title":"用 github api 上传文件的方法"},{"content":"\n\n\u003e 建议先了解一下 rsa 原理，再看本文。推荐阮一峰老师的两篇文章：  \n\u003e* [rsa 算法原理（一）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)  \n\u003e* [rsa 算法原理（二）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)  \n\n因为`php`支持的密钥格式是`.pem`所以`web`和`java`端都要将`pem`格式转换成其语言平台支持的格式。 比如，`java`支持的格式默认是`.asn`。   \n### 密钥对的生成( php )  \n\nrsa 的密钥是由两个数字组成。生成这些密钥有 3 步：  \n1. 创建两个随机的非常大的质数。这两个数字分别称为 p 和 q 。将 p 和 q 相乘得到一个数字，把它称做 n 。  \n2. 创建一个随机数，称为 e ，使它与 (p-1)*(q-1) 互质。  \n3. 计算 e 的模逆，这个数字称为 d 。  \n(n 和 e 组成公钥，n 和 d 组成私钥。两个密钥都包含了数字 n 。)    \n虽然可以正确地实现 rsa 算法，但还有一些微妙的错误会导致加密消息遭到破译。所以还是要基于一些专业的第三方库或软件，比如`openssl`，来实现加密数据。    \n\n如果系统是`linux`的话，可以使用`openssl`命令来生成。这里展示的是在`windows`系统下的操作(因为当时做这个东西的时候是在 windows 8.1 系统下完成的)，使用 [xampp](https://www.apachefriends.org/zh_cn/index.html) 集成好的`openssl`(其配置文件路径在 xampp 的安装路径下的php\\extras\\openssl\\openssl.cnf，我们这次使用的就是这个文件)，下面展示用`php`来生成密钥对：    \n```php\n\u003c?php\n//openssl_cnf为 openssl.cnf 的路径\ndefine('openssl_cnf','\u003cyour openssl.cnf path \u003e');\ndefine('sha',\"sha512\");\ndefine('length',2048);\n\nheader(\"content-type:text/html;charset=utf-8\");\n$configargs=array(\n\t'config'=\u003e openssl_cnf,\n\t\"digest_alg\" =\u003e sha,\n    \"private_key_bits\" =\u003e length,\n    \"private_key_type\" =\u003e openssl_keytype_rsa,);\n$res=openssl_pkey_new($configargs);\nopenssl_pkey_export($res,$pri,null, $configargs);\n\n/*binary data to decimal data\n * @param string $data\n * @return string $result\n * */\nfunction hextobin($hexstring) \n    { \n        $hexlenght = strlen($hexstring); \n        // only hexadecimal numbers is allowed \n        if ($hexlenght % 2 != 0 || preg_match(\"/[^\\da-fa-f]/\",$hexstring)) return false; \n\n        unset($binstring); \n        for ($x = 1; $x \u003c= $hexlenght/2; $x++) \n        { \n                $binstring .= chr(hexdec(substr($hexstring,2 * $x - 2,2))); \n        } \n\n        return $binstring; \n    } \n \n/* binary data to decimal data\n * @param string $data\n * @return string $result\n **/\nfunction bintodec($data)\n\t{\n\t\t$base = \"256\";\n\t\t$radix = \"1\";\n\t\t$result = \"0\";\n\n\t\tfor($i = strlen($data) - 1; $i \u003e= 0; $i--)\n\t\t{\n\t\t\t$digit = ord($data{$i});\n\t\t\t$part_res = bcmul($digit, $radix);\n\t\t\t$result = bcadd($result, $part_res);\n\t\t\t$radix = bcmul($radix, $base);\n\t\t}\n\n\t\treturn $result;\n\t}\n\n$details=openssl_pkey_get_details($res);\n\n$n_hex=bin2hex($details['rsa']['n']);\n$d_hex=bin2hex($details['rsa']['d']);\n$e_hex=bin2hex($details['rsa']['e']);\n\n$n_dec=bintodec($details['rsa']['n']);\n$d_dec=bintodec($details['rsa']['d']);\n$e_dec=bintodec($details['rsa']['e']);\n\nopenssl_pkey_free($res);\n\n$pub=$details['key'];\n\n$crtpath = \"./test.crt\"; //公钥文件路径  \n$pempath = \"./test.pem\"; //私钥文件路径  \n\n$n_hexpath = \"./n_hex.key\"; //n_hex文件路径  \n$d_hexpath = \"./d_hex.key\"; //d_hex文件路径  \n$e_hexpath = \"./e_hex.key\"; //e_hex文件路径 \n\n$n_decpath = \"./n_dec.key\"; //n_dec文件路径  \n$d_decpath = \"./d_dec.key\"; //d_dec文件路径  \n$e_decpath = \"./e_dec.key\"; //e_dec文件路径 \n\n//生成证书文件  \n$fp = fopen($crtpath, \"w\");  \nfwrite($fp, $pub);  \nfclose($fp);  \n\n$fp = fopen($pempath, \"w\");  \nfwrite($fp, $pri);  \nfclose($fp);  \n//生成n_hex,d_hex,e_hex文件\n$fp = fopen($n_hexpath, \"w\");  \nfwrite($fp, $n_hex);  \nfclose($fp);  \n\n$fp = fopen($d_hexpath, \"w\");  \nfwrite($fp, $d_hex);  \nfclose($fp);  \n\n$fp = fopen($e_hexpath, \"w\");  \nfwrite($fp, $e_hex);  \nfclose($fp); \n//生成n_dec,d_dec,e_dec文件\n$fp = fopen($n_decpath, \"w\");  \nfwrite($fp, $n_dec);  \nfclose($fp);  \n\n$fp = fopen($d_decpath, \"w\");  \nfwrite($fp, $d_dec);  \nfclose($fp);  \n\n$fp = fopen($e_decpath, \"w\");  \nfwrite($fp, $e_dec);  \nfclose($fp); \n\nvar_dump($pub);\necho \"\u003cbr/\u003e\";\nvar_dump($pri);\n$pu_key = openssl_pkey_get_public($pub);\nprint_r($pu_key);\necho \"\u003cbr/\u003e\";\n$data = 'plaintext data goes here.';\n\n// encrypt the data to $encrypted using the public key\nopenssl_public_encrypt($data, $encrypted,$pub,openssl_pkcs1_padding);\n\n// decrypt the data using the private key and store the results in $decrypted\nopenssl_private_decrypt($encrypted, $decrypted, $pri,openssl_pkcs1_padding);\n\necho $encrypted.\" \".strlen($encrypted).\"   \".base64_encode($encrypted).\"\u003cbr/\u003e\";\necho $decrypted;\n?\u003e\n```  \n### java\n\u003e 此处的核心代码是我从互联网上搜索到的，出处已经记不清是哪了，还请原作者见谅。  \n\n```java\nprivate string _key;\nprivate keyformat _format;\nprivate cipher _decryptprovider;\nprivate cipher _encryptprovider;\n\npublic keyworker(string key) {\n\tthis(key, keyformat.asn);\n}\n\npublic keyworker(string key, keyformat format) {\n\tthis._key = key;\n\tthis._format = format;\n}\n\npublic string encrypt(string data) throws illegalblocksizeexception,\nbadpaddingexception, invalidkeyexception, nosuchalgorithmexception,\nnosuchpaddingexception, invalidkeyspecexception, ioexception, saxexception, parserconfigurationexception {\n\tthis._makesureencryptprovider();\n\tbyte[] bytes = data.getbytes(\"utf-8\");\n\tbytes = this._encryptprovider.dofinal(bytes);\n\treturn new base64encoder().encode(bytes);\n}\n\npublic string decrypt(string data) throws ioexception,\nillegalblocksizeexception, badpaddingexception,\ninvalidkeyexception, nosuchalgorithmexception,\nnosuchpaddingexception, invalidkeyspecexception, saxexception, parserconfigurationexception {\n\tthis._makesuredecryptprovider();\n\t\n\tbyte[] bytes = new base64decoder().decodebuffer(data);\n\tbytes = this._decryptprovider.dofinal(bytes);\n\treturn new string(bytes, \"utf-8\");\n}\n\nprivate void _makesuredecryptprovider() throws nosuchalgorithmexception,\nnosuchpaddingexception, ioexception, invalidkeyspecexception,\ninvalidkeyexception, saxexception, parserconfigurationexception {\nif (this._decryptprovider != null)\n\treturn;\n\ncipher decipher = cipher.getinstance(\"rsa/ecb/pkcs1padding\");\nswitch (this._format) {\n\ncase pem: {\n\tthis._key = this._key.replace(\"-----begin public key-----\", \"\")\n\t\t\t.replace(\"-----end public key-----\", \"\")\n\t\t\t.replace(\"-----begin private key-----\", \"\")\n\t\t\t.replace(\"-----end private key-----\", \"\")\n\t\t\t.replaceall(\"\\r\\n\", \"\");\n}\ncase asn:\ndefault: {\n\tboolean isprivate = this._key.length() \u003e 500;\n\tif (isprivate) {\n\t\tpkcs8encodedkeyspec spec = new pkcs8encodedkeyspec(\n\t\t\t\tnew base64decoder().decodebuffer(this._key));\n\n\t\tkeyfactory factory = keyfactory.getinstance(\"rsa\");\n\t\trsaprivatekey privatekey = (rsaprivatekey) factory\n\t\t\t\t.generateprivate(spec);\n\t\tdecipher.init(cipher.decrypt_mode, privatekey);\n\t} else {\n\t\tx509encodedkeyspec spec = new x509encodedkeyspec(\n\t\t\t\tnew base64decoder().decodebuffer(this._key));\n\n\t\tkeyfactory factory = keyfactory.getinstance(\"rsa\");\n\t\trsapublickey publickey = (rsapublickey) factory\n\t\t\t\t.generatepublic(spec);\n\t\tdecipher.init(cipher.decrypt_mode, publickey);\n\t}\n}\n\tbreak;\n}\n\nthis._decryptprovider = decipher;\n}\n\nprivate void _makesureencryptprovider() throws nosuchalgorithmexception,\nnosuchpaddingexception, ioexception, invalidkeyspecexception,\ninvalidkeyexception, saxexception, parserconfigurationexception {\nif (this._encryptprovider != null)\n\treturn;\n\ncipher encipher = cipher.getinstance(\"rsa/ecb/pkcs1padding\");\nswitch (this._format) {\n\ncase pem: {\n\tthis._key = this._key.replace(\"-----begin public key-----\", \"\")\n\t\t\t.replace(\"-----end public key-----\", \"\")\n\t\t\t.replace(\"-----begin private key-----\", \"\")\n\t\t\t.replace(\"-----end private key-----\", \"\")\n\t\t\t.replaceall(\"\\r\\n\", \"\");\n}\ncase asn:\ndefault: {\n\tboolean isprivate = this._key.length() \u003e 500;\n\tif (isprivate) {\n\t\tpkcs8encodedkeyspec spec = new pkcs8encodedkeyspec(\n\t\t\t\tnew base64decoder().decodebuffer(this._key));\n\n\t\tkeyfactory factory = keyfactory.getinstance(\"rsa\");\n\t\trsaprivatekey privatekey = (rsaprivatekey) factory\n\t\t\t\t.generateprivate(spec);\n\t\tencipher.init(cipher.encrypt_mode, privatekey);\n\n\t} else {\n\t\tx509encodedkeyspec spec = new x509encodedkeyspec(\n\t\t\t\tnew base64decoder().decodebuffer(this._key));\n\n\t\tkeyfactory factory = keyfactory.getinstance(\"rsa\");\n\t\trsapublickey publickey = (rsapublickey) factory\n\t\t\t\t.generatepublic(spec);\n\t\tencipher.init(cipher.encrypt_mode, publickey);\n\t}\n}\n\tbreak;\n}\n\t\tthis._encryptprovider = encipher;\n\t}\n```  \n以上代码核心就是将其它密钥格式转换成`.pem`格式，和`php`后台那边适配。    \n### web  \n由于是前端，所以只做加密数据。然后必须先将密钥对‘分解’成 'n' , 'd' , 'e'。上代码：  \n```html\n\u003c!doctype html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003ctitle\u003ejavascript rsa encryption \u003c/title\u003e\n\u003c/head\u003e\n \n\u003cscript language=\"javascript\" type=\"text/javascript\" src=\"./js/jsbn.js\"\u003e\u003c/script\u003e\n\u003cscript language=\"javascript\" type=\"text/javascript\" src=\"./js/prng4.js\"\u003e\u003c/script\u003e\n\u003cscript language=\"javascript\" type=\"text/javascript\" src=\"./js/rng.js\"\u003e\u003c/script\u003e\n\u003cscript language=\"javascript\" type=\"text/javascript\" src=\"./js/rsa.js\"\u003e\u003c/script\u003e\n\u003cscript language=\"javascript\" type=\"text/javascript\" src=\"./js/base64.js\"\u003e\u003c/script\u003e\n\u003cscript language=\"javascript\"\u003e \n//publc key  and public length hex data\nvar public_key=\"b3a55f5100b87959ef1bd60508fca4f547af9a0617e8eea1a69a9f7f3f669ee01d89033a7521fa25c6437c6e4c4e0237afc23dbc3f1597b3a0a2181b45aae5effbb787cf6ced26fc042168bad462d916323246ce923c6fa22b6baf62f2a8f93a753b21b3fcd4c5789d89ca02badb88081452a5ecc12d88374475bfa409627e9014600d1b821b76b8b44e6d43bf28eb9fbb68a7b40e5c778d8ff63798764277c040432b9b27a682c8e1c202e95e8c3b826d5188c389716bb4a7278761a7b22ff39ede130c1b9022449f190a79846ea616fec3e1056e8f24a7b3b508ca734ea2c8a92f2c97adc4afd391a52e04504fd69553b4e048650a44ebdaa889701256d315\";\nvar public_length=\"0010001\";\nfunction do_encrypt() {\n  var before = new date();\n  var rsa = new rsakey();\n  rsa.setpublic(public_key, public_length);\n  var res = rsa.encrypt(document.rsatest.plaintext.value);\n  var after = new date();\n  if(res) {\n    document.rsatest.ciphertext.value =res;\n    document.rsatest.cipherb64.value = hex2b64(res);\n    document.rsatest.status.value = \"time: \" + (after - before) + \"ms\";\n  }\n}\n\n\u003c/script\u003e\n \n\u003cform name=\"rsatest\" action=\"rsa.php\" method=\"post\"\u003e\nplaintext (string):\u003cbr\u003e\n\u003cinput name=\"plaintext\" type=\"text\" value=\"test\" size=40\u003e\n\u003cinput type=\"button\" value=\"encrypt\" onclick=\"do_encrypt();\"\u003e\u003cp\u003e\nciphertext (hex):(not used)\u003cbr\u003e\n\u003ctextarea name=\"ciphertext\" rows=4 cols=70\u003e\u003c/textarea\u003e\u003cp\u003e\nciphertext (base64):\u003cbr\u003e\n\u003ctextarea name=\"cipherb64\" rows=3 cols=70\u003e\u003c/textarea\u003e\u003cp\u003e\nstatus:\u003cbr\u003e\n\u003cinput name=\"status\" type=\"text\" size=40\u003e\u003cp\u003e\n\u003cinput type=\"submit\" value=\"submit\" /\u003e\n\u003c/form\u003e\n  \u003cbody\u003e\n\u003chtml\u003e\n```  \n  \n##### 对应的 php 后台解密：  \n```php\n\u003c?php \n//header(\"content-type:text/javascript;charset=utf-8\");\n$encrypted=$_post['cipherb64'];\n$public_key = file_get_contents(\"../public.crt\");\n$private_key = file_get_contents(\"../private.pem\");\n\n//var_dump(base64_decode($encrypted));\n\n$pu_key = openssl_pkey_get_public($public_key);//这个函数可用来判断公钥是否是可用的\n$pi_key = openssl_pkey_get_private($private_key);//这个函数可用来判断私钥是否是可用的，可用返回资源id resource id\n//var_dump($pu_key);\n//var_dump($pi_key);\nopenssl_private_decrypt(base64_decode($encrypted),$decrypted,$pi_key);//私钥解密\necho \"\\n\";\nvar_dump($decrypted);\necho \"\\n\".\"共\".strlen($decrypted).\"个字节。\";\n?\u003e\n ```\n### 源代码分享\n以上全部代码在我的 github 托管。[传送门](https://github.com/zetaoyang/rsa)\n\n\n\n\n\n\n","cover":"","link":"./post/2016/10/06/rsa.html","preview":"\u003cp\u003e建议先了解一下 rsa 原理，再看本文。推荐阮一峰老师的两篇文章\u003c/p\u003e\n","title":"非对称加密( rsa )数据传送的实战"},{"content":"\n\n*以下方法适合于 windows 用户，如果是 linux或者 mac 用户可以直接用终端的命令进行操作。*  \n\n#### 一、列出已存在的 ssh key  \n方法1.打开 git bash，并且输入：  \n`ls ‐al ~/.ssh\n`  \n\n方法2.打开 [cmder](http://cmder.net/) ，并且输入：   \n`ls ‐al ~/.ssh\n`  \n\n#### 二、生成密钥   \n方法1.用 git bash，然后输入：  \n`ssh‐keygen ‐t rsa ‐c \"your_email@example.com\"\n`   \n\n这个命令将会生成一个以 your_email@example.com 为标签的 ssh key，然后 bash 中会显示：  \ngenerating public/private rsa key pair.\nenter file in which to save the key (/c/users/you/.ssh/id_rsa): [press enter]   \n\n*注*：此处私钥的名称可以自定义，即可以不使用默认的名称 ‘id_rsa’。\n另外还有一个常识，rsa 加密算法它的**公钥是从私钥提取而来**。\n\n直接回车，然后出现：  \nenter passphrase (empty for no passphrase): [type a passphrase]\nenter same passphrase again: [type passphrase again]   \n\n因为追求操作方便，所以不打算在 deploy 的时候输入这个 passphrase ，所以直接回车两次设为空。然后你会看到：  \n`your identification has been saved in ~/.ssh/id_rsa.\n your public key has been saved in ~/.ssh/id_rsa.pub.\nthe key fingerprint is:\n01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com\n`  \n\n#### 三、加入ssh agent  \n\n下一步在 git bash 或者 cmder 中输入：\n\n`ssh‐agent ‐s\n`   \n\n如果出现类似 agent pid xxxx 这样的字样，则跳过下一步，否则输入：  \n``eval `ssh‐agent ‐s`\n``\n\n*注*：此处用 cmder 可能会出现下面的提示  \ncmder - 'eval' command is not recognized   \n解决方法：使用`bash`命令进入\nbash shell。然后`eval`就可以使用了。   \n\n直到出现 agent pid xxxx 这样的提示之后，输入：    \n`ssh‐add ~/.ssh/id_rsa\n`  \n\n这样，就成功的在本地生成了一个可用的ssh key。  \n#### 四、将ssh key添加到github中   \n\n下面将这个 key 添加到 github 网站。 \n打开https://github.com/settings/ssh,  点击 add ssh key ，复制 id_rsa.pub(或者是你自己重命名的公钥名称) 中的所有内容到 key 框中，在 title 框中输入方便自己记忆的名字（建议输入能让自己明白是哪台电脑的名字，方便以后管理）。 \n当网页显示添加成功后，就已经完成了全部的操作。\n下面进行一些测试，同样是打开 git bash 或 cmder，输入： \n`ssh ‐t git@github.com\n`\n bash 或 cmder 中会显示如下字样：\n`the authenticity of host 'github.com (207.97.227.239)' can't be established.\nrsa key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\nare you sure you want to continue connecting (yes/no)?  \n`  \n\n输入 yes 之后，计算机会自动将 github.com 列入已知的 host，然后会出现如下提示：   \n\n`hi username! you've successfully authenticated, but github does not\nprovide shell access.    \n`  \n\n如果成功看见，说明你已经配置好了。 \n如果出现任何错误提示，请仔细检查自己的操作。  \n\n*另外* 由于 ssh 配置文件的不匹配，导致的 permission denied (publickey)及其解决方法：一定要保持新生成的密匙文件的名字同 “ssh_config” 中 “identityfile” 字段的值一致即可，其中`ssh_config`文件在`{git的安装路径}\\etc\\ssh\\ssh_config`路径。\n例如：  \n```\nhost github.com\n\tuser git\n\tstricthostkeychecking no\n\tidentityfile ~/.ssh/{你的rsa私钥的名称}\n\tidentitiesonly yes\n```\n","cover":"","link":"./post/2016/07/09/hexo-ssh-key.html","preview":"\u003cp\u003e以下方法适合于 windows 用户，如果是 linux或者 mac 用户可以直接用终端的命令进行操作。\u003c/p\u003e\n","title":"使用 github ssh key 部署 hexo 博客"},{"content":"\n\n一、要使用搜索，必须先生成博客索引数据，hexo  可以通过下面的这个插件生成：\n```\nnpm install hexo-generator-search --save\n\n```\n二、只需要在 hexo 站点 _config.yml 中添加如下配置即可：\n```\nsearch:\n  path: search.xml\n  field: post\n```\n- **path** - file path. default is `search.xml` .\n- **field** - the search scope you want to search, you can chose:\n  * **post** (default) - will only covers all the posts of your blog.\n  * **page** - will only covers all the pages of your blog.\n  * **all** - will covers all the posts and pages of your blog.\n\n\n   更多配置说明可到插件页面查看：[hexo-generator-search](https://github.com/paichyperiondev/hexo-generator-search)  \n\n三、然后在 themes/next/layout/_partials/search 目录下修改 localsearch.swig 文件。  \n  原始文件内容如下：   \n\n```javascript\n \u003cscript type=\"text/javascript\"\u003e\n     var search_path = \"\u003c%= config.search.path %\u003e\";\n     if (search_path.length == 0) {\n     \tsearch_path = \"search.xml\";\n     }\n     var path = \"\u003c%= config.root %\u003e\" + search_path;\n     searchfunc(path, 'local-search-input', 'local-search-result');\n \u003c/script\u003e\n```\n\n 修改后的文件内容为:  \n\n```html\n\u003cdiv class=\"popup\"\u003e\n \u003cspan class=\"search-icon fa fa-search\"\u003e\u003c/span\u003e\n \u003cinput type=\"text\" id=\"local-search-input\" placeholder=\"search my blog...\"\u003e\n \u003cdiv id=\"local-search-result\"\u003e\u003c/div\u003e\n \u003cspan class=\"popup-btn-close\"\u003eclose\u003c/span\u003e\n\u003c/div\u003e\n```  \n\n其他的地方都不需要改，这样 hexo 本地站内搜索就完成了。\n","cover":"","link":"./post/2016/07/08/hexo-localsearch.html","preview":"\u003cp\u003e一、要使用搜索，必须先生成博客索引数据，hexo  可以通过下面的这个插件生成\u003c/p\u003e\n","title":"实现 hexo next 主题博客本地站内搜索"}]